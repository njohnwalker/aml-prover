**********************************
*** Applicative Matching Logic ***
*** Interactive Theorem Prover ***
**********************************

in checker/checker/maude/checker.maude

fmod AML-CHECKER is
    extending CHECKER * (sort Rule to AMLRule, op ___;_ to ___;;_ ) .

    *** avoid applying the equation that erases comments for ease of use
    *** mimmic the operator syntax so printed output can be read by the checker
    sort CommentedProofStep CommentedProof .
    subsort ProofStep < Proof CommentedProofStep < CommentedProof .

    op ___;_ : Id Claim AMLRule String -> CommentedProofStep [ctor] .

    op __ : CommentedProof CommentedProof -> CommentedProof [ctor ditto] .
    op __ : CommentedProof          Proof -> CommentedProof [ctor ditto] .
    op __ :          Proof CommentedProof -> CommentedProof [ctor ditto] .

    *** Explicitly convert back to the original proof constructor
    op stripComments : CommentedProof -> Proof .
    eq stripComments(Pi1 Id C Rule ; S Pi2) =
        stripComments(Pi1 Id C Rule ;; S Pi2 ) .
    eq stripComments(Pi1) = Pi1 [owise] .

    *** Helpers
    ops check check-id check-step : CommentedProof -> Bool .
    eq check(Proof) = check(stripComments(Proof)) .
    eq check-id(Proof) = check-id(stripComments(Proof)) .
    eq check-step(Proof) = check-step(stripComments(Proof)) .

    op getStepNum : CommentedProof ~> Nat .
    eq getStepNum(Pi1 (N) C Rule ;) = N .
    eq getStepNum(Pi1 (N) C Rule ; S) = N .

    *** Non-total, fails for unproved well-formed pattern Ids
    op getClaimId : Id CommentedProof ~> Id .
    eq getClaimId(Id, Pi1 (Id' Id Rule ;  ) Pi2) = Id' .
    eq getClaimId(Id, Pi1 (Id' Id Rule ; S) Pi2) = Id' .

    op getStepId : Claim AMLRule CommentedProof ~> Id .
    eq getStepId(C, Rule, Pi1 Id C Rule ;   Pi2) = Id .
    eq getStepId(C, Rule, Pi1 Id C Rule ; S Pi2) = Id .

    op _[_] : CommentedProof Id ~> Claim .
    eq (Pi1 (Id Claim Rule ;   ) Pi2) [Id] = Claim .
    eq (Pi1 (Id Claim Rule ; S ) Pi2) [Id] = Claim .

    sorts VariableClaim BasicClaim .
    subsorts VariableClaim < BasicClaim < Claim .
    ops `(\evar`) `(\svar`) : -> VariableClaim .
    op  `(\symb`) : -> BasicClaim .

    sort ProofAndIndex .
    op {_,_} : CommentedProof Id -> ProofAndIndex .
    op getProof : ProofAndIndex -> CommentedProof .
    eq getProof({Proof, Id}) = Proof .

    op appendProofStep : Claim AMLRule CommentedProof -> ProofAndIndex .
    ceq  appendProofStep(BasicClaim, Rule, Proof) =
        { Proof (N) BasicClaim Rule ;, (N) }
      if N := s getStepNum(Proof) .
    ceq appendProofStep(Claim, Rule, Proof) =
        { Proof, Id }
      if Id := getStepId(Claim, Rule, Proof) [owise] .
    ceq appendProofStep(Claim, Rule, Proof) =
        { Proof (N) Claim Rule ;, (N) }
      if N := s getStepNum(Proof) [owise] .

    vars N M : Nat .
    vars Id Id' : Id .
    var BasicClaim : BasicClaim .
    vars C Claim : Claim . var Rule : AMLRule . var S : String .
    vars Pi1 Pi2 Proof : CommentedProof .
    var PrStep : ProofStep .
endfm

******************************
*** AML Syntax Definitions ***
******************************
fmod VARIABLES is
    protecting AML-CHECKER .
    protecting QID .
    sorts EVar SVar Var .
    subsort EVar SVar < Var .
    op evar : Qid -> EVar [ctor] .
    op svar : Qid -> SVar [ctor] .

    op getVarName : Var -> Qid .
    eq getVarName(evar(Q)) = Q .
    eq getVarName(svar(Q)) = Q .

    op getVarType : Var -> Claim .
    eq getVarType(EV) = (\evar) .
    eq getVarType(SV) = (\svar) .

    var Q : Qid . var EV : EVar . var SV : SVar .
endfm

fmod AML-CORE is protecting VARIABLES .
    protecting EXT-BOOL .
*** terse AML Patterns

    sorts Symbol Pattern .
    subsort Var Symbol < Pattern .

    *** Bottom
    op bot : -> Pattern [ctor] .

    *** Pattern Application
    op _@_ : Pattern Pattern -> Pattern
          [ctor prec 40  gather (E e) format (d s ++s --)] .

    *** Patten Implication
    op _-->_ : Pattern Pattern -> Pattern [ctor gather (e E) format (d s s++ --)] .

    *** Universal quantification
    op exists_._ : EVar Pattern -> Pattern [ctor prec 42 format (d s s s++ --)] .

    *** least fixpoint
    op mu_._ : SVar Pattern ~> Pattern [ctor prec 42 format (d s s s++ --)] .
    *** condition on set variable fixpoints
    cmb mu X . P : Pattern if nonNegative(X, P) .

    op nonNegative : SVar Pattern -> Bool .
    eq nonNegative(X,P) = $nonNegative(true, X, P) .

    op $nonNegative : Bool SVar Pattern -> Bool .
    eq $nonNegative(B, X, bot) = true .
    eq $nonNegative(B, X, S) = true .
    eq $nonNegative(B, X, X) = B .
    eq $nonNegative(B, X, V) = true [owise] .
    eq $nonNegative(B, X, P @ Q) = $nonNegative(B, X, P) and-then $nonNegative(B, X, Q) .
    eq $nonNegative(B, X, P --> Q) = $nonNegative(not B, X, P) and-then $nonNegative(B, X, Q) .
    eq $nonNegative(B, X, exists (x:EVar) . P) = $nonNegative(B, X, P) .
    eq $nonNegative(B, X, mu X . P) = true .
    eq $nonNegative(B, X, mu X' . P) = $nonNegative(B, X, P) .

    op isFreeIn : Var Pattern -> Bool .
    eq isFreeIn(V, bot) = false .
    eq isFreeIn(V, V') = V == V' .
    eq isFreeIn(V, S) = false .
    eq isFreeIn(V, P @ Q) = isFreeIn(V, P) or-else isFreeIn(V, Q) .
    eq isFreeIn(V, P --> Q) = isFreeIn(V, P) or-else isFreeIn(V, Q) .
    eq isFreeIn(V, exists V . P) = false .
    eq isFreeIn(V, exists V' . P) = isFreeIn(V, P) .
    eq isFreeIn(V, mu V . P) = false .
    eq isFreeIn(V, mu V' . P) = isFreeIn(V, P) .

    var B : Bool .
    vars X X' : SVar .
    vars V V' : Var .
    var S : Symbol .
    vars P Q : Pattern .
endfm

view Pattern from TRIV to AML-CORE is sort Elt to Pattern . endv
view Symbol  from TRIV to AML-CORE is sort Elt to Symbol  . endv
view Var     from TRIV to AML-CORE is sort Elt to Var     . endv

fmod PATTERN-SET is
    inc SET{Pattern} *
        ( sort NeSet{Pattern} to NePatternSet
        , sort Set{Pattern} to PatternSet
        ) .
endfm

fmod PATTERN-LIST is
    inc LIST{Pattern} *
        ( sort NeList{Pattern} to NePatternList
        , sort List{Pattern} to PatternList
        ) .
endfm

fmod AML is including AML-CORE .
    protecting PATTERN-SET .
*** Add syntactic sugar and variable substitution
*** to AML core representation

    vars P Q P' : Pattern .
    var x : EVar .
    vars X X' : SVar .
    var S : Symbol .
    vars V V' : Var .

    *** Top
    op top : -> Pattern .
    eq top = exists evar('x) . evar('x) .

    *** Not
    op ~_ : Pattern -> Pattern .
    eq ~ P = P --> bot .

    *** Or, And
    ops _\/_ _/\_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P \/ Q = (~ P) --> Q .
    eq P /\ Q = ~((~ P) \/ (~ Q)) .


    *** If-and-only-if
    op _<-->_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P <--> Q = (P --> Q) /\ (Q --> P) .

    *** Quantifiers
    op forall_._ : EVar Pattern -> Pattern .
    eq forall x . P = ~ (exists x . ~ P ) .

    *** greatest fixpoint
    op nu_._ : EVar Pattern ~> Pattern .
    eq nu X . P = ~ (mu X . ~ (P[~ X / X])) .

    ********************
    *** Substitution ***
    op _[_/_] : Pattern Pattern Var ~> Pattern [prec 39].

    *** Alpha capture substitution side-condition
    op alphaCapture : -> [Pattern] .
    ceq P [Psub / V] = alphaCapture if alphaCaptures(V, P, Psub) .

    eq bot[Psub / V] = bot .
    eq S[Psub / V] = S .
    eq V[Psub / V] = Psub .
    eq V'[Psub / V] = V' .

    eq (P @ P')[Psub / V] = (P[Psub / V]) @ (P'[Psub / V]) .

    eq (P --> P')[Psub / V] = P[Psub / V] --> (P'[Psub / V]) .

    eq (exists V . P)[Psub / V] = exists V . P .
    eq (exists V' . P)[Psub / V] = exists V' . (P[Psub  / V]) .

    eq (mu V . P)[Psub / V] = mu V . P .
    eq (mu V' . P)[Psub / V] = mu V' . (P[Psub  / V]) .

    var B : Bool .
    var Psub : Pattern .
    var Vb : Var .
    op alphaCaptures : Var Pattern Pattern -> Bool .
    eq alphaCaptures(V, P, Psub) = $alphaCaptures(false, V, P, Psub) .

    op $alphaCaptures : Bool Var Pattern Pattern -> Bool .
    eq $alphaCaptures(B, Vb, Vb, Psub) = B .

    eq $alphaCaptures(B, Vb, bot, Psub) = false .

    eq $alphaCaptures(B, Vb, V', Psub) = false .

    eq $alphaCaptures(B, Vb, S, Psub) = false .

    eq $alphaCaptures(B, Vb, P @ P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, P --> P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, exists Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, exists V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .

    eq $alphaCaptures(B, Vb, mu Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, mu V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .

    *** Application Contexts
    sort ApplicationContext .
    op [] : -> ApplicationContext [ctor] .
    op _@_ : Pattern ApplicationContext -> ApplicationContext
          [ctor prec 40  gather (E e) format (d s ++s --)] .
    op _@_ : ApplicationContext Pattern -> ApplicationContext
          [ctor prec 40  gather (E e) format (d s ++s --)] .

    var Ctx : ApplicationContext .
    op _[_] : ApplicationContext Pattern -> Pattern .
    eq [] [Psub] = Psub .
    eq  Ctx @ P [Psub] = (Ctx[Psub]) @ P .
    eq  P @ Ctx [Psub] = P @ (Ctx[Psub]) .

    var PS : PatternSet .
    op getSymbols : PatternSet -> PatternSet .
    eq getSymbols(S) = S .
    eq getSymbols(bot) = empty .
    eq getSymbols(V) = empty .
    eq getSymbols(P @ P') = getSymbols(P) , getSymbols(P') .
    eq getSymbols(P --> P') = getSymbols(P) , getSymbols(P') .
    eq getSymbols(exists V . P) = getSymbols(P) .
    eq getSymbols(mu V . P) = getSymbols(P) .
    eq getSymbols((P, PS)) = getSymbols(P) , getSymbols(PS) .

    op getVars : PatternSet -> PatternSet .
    eq getVars(V) = V .
    eq getVars(bot) = empty .
    eq getVars(S) = empty .
    eq getVars(P @ P') = getVars(P) , getVars(P') .
    eq getVars(P --> P') = getVars(P) , getVars(P') .
    eq getVars(exists V . P) = V, getVars(P) .
    eq getVars(mu V . P) = V, getVars(P) .
    eq getVars((P, PS)) = getVars(P) , getVars(PS) .
endfm

***********************
*** PRETTY PRINTING ***
***********************
fmod META-LEVEL' is pr META-LEVEL * ( op _`,_ to _~_, op [] to [o] ) .
endfm

fmod PRETTY is pr AML .
    pr META-LEVEL' .

    *** Natural Numbers
    vars N : Nat .
    op pretty : Nat -> QidList .
    eq pretty(N:Nat) = metaPrettyPrint(['NAT], upTerm(N:Nat)) .

    op prettyString : Nat -> String .
    eq prettyString(N) = string(pretty(N)) .

    *** Patterns
    var P : Pattern .
    op pretty : Pattern -> QidList .
    eq pretty(P) = metaPrettyPrint(['AML-USER-THEORY], upTerm(P)) .

endfm

in aml-user-theory.maude

**********************
*** Prover Modules ***
**********************
mod AML-GOAL is including AML .
    pr PRETTY .
    pr PATTERN-LIST .
    sorts ConsequentMap AntecedentMap .

    op mt : -> AntecedentMap [ctor] .
    op mt : -> ConsequentMap [ctor] .
    op [-_`(_`):_] : Nat Nat Pattern -> AntecedentMap [ctor format (d s d s d d d n++i -- d) ] .
    op  [_`(_`):_] : Nat Nat Pattern -> ConsequentMap [ctor format (d sss s d d d n++i -- d) ] .
    op _;_ : AntecedentMap AntecedentMap -> AntecedentMap [ctor assoc id: mt format (d s n d) ] .
    op _;_ : ConsequentMap ConsequentMap -> ConsequentMap [ctor assoc id: mt format (d s n d) ] .

    sort Goal .
    op _|-_ : AntecedentMap ConsequentMap -> Goal [ctor prec 100 format (d nt n d)] .
    op proved : Pattern Id Id -> Goal [ctor] .

    sort GoalMap .
    op mt : -> GoalMap [ctor] .
    op [_`(_`):_] : Nat Nat Goal -> GoalMap [ctor] .
    op _;_ : GoalMap GoalMap -> GoalMap [ctor assoc id: mt] .

*** Antecedent Map Invariant
*** requires: exists a (-1) indexed element in the map
    crl [antecedentMapInvariant] :
        [- N (I): P] ; [- M (I'): P'] => [- s M (I): P] ; [- M (I'): P']
      if N == M or N > s M .

*** Consequent and Goal Map invariants
*** requires: exists a 0 indexed element in the map
    crl [consequentMapInvariant] :
        [N (I): P] ; [M (I'): P'] => [N (I): P] ; [s N (I'): P']
      if M == N or M > s N .

    crl [goalMapInvariant] :
        [N (I): G] ; [M (I'): G'] => [N (I): G] ; [s N (I'): G']
      if M == N or M > s N .

    *** Construct a AntecedentMap from a set of Patterns
    op makeClaim : PatternList Pattern -> Pattern .
    eq makeClaim(nil, Conclusion) = Conclusion .
    eq makeClaim(P PL, Conclusion) = P --> makeClaim(PL, Conclusion) .

    *** Print a GoalMap
    op pretty : GoalMap -> QidList .
    eq pretty([N (I): AM |- [0 (I): P]; CM] ; GM) =
        pretty(N) ': '... '|- pretty(P) '\n
        pretty(GM) .
    eq pretty(mt) = nil .

    op fresh : AntecedentMap -> Nat .
    eq fresh((mt).AntecedentMap) = 1 .
    eq fresh([- N (I): P] ; AM) = s N .

    op fresh : ConsequentMap -> Nat .
    eq fresh((mt).ConsequentMap) = 0 .
    eq fresh(CM ; [N (I): P]) = N .

    var AM : AntecedentMap . var CM : ConsequentMap . var GM : GoalMap .
    vars N M I I' : Nat .
    vars P P' Conclusion : Pattern .
    var PL : PatternList .
    vars G G' : Goal .
endm

*** Module to metaPrettyPrint all user space AML symbols and Proof goals
*** useful for more efficient meta-representation of module to print in
mod PRINT-AML-GOAL is protecting AML-GOAL + AML-USER-THEORY . endm

mod AML-PROOF-STATE is
    pr AML-GOAL . inc AML-CHECKER .
    pr PRINT-AML-GOAL .

    pr PATTERN-SET .
    pr MAP{Symbol, Nat} * ( op undefined to undefinedSym, op _|->_ to _|-S>_ ) .
    pr MAP{Var, Nat} * ( op undefined to undefinedVar, op _|->_ to _|-V>_ ) .

    sort ProofState .
    op .ProofState : -> ProofState [ctor] .
    op _^_ : ProofState ProofState -> ProofState [assoc comm ctor format (d ni s d)] .

    ops goalCounter : Nat -> ProofState [ctor] .
    op goals : GoalMap -> ProofState [ctor format (++ --)] .

    op symbolIndex : Map{Symbol,Nat} -> ProofState [ctor] .

    op variableIndex : Map{Var,Nat} -> ProofState [ctor] .

    *** intermediate proof objects
    op hilbertProof : CommentedProof -> ProofState [ctor] .
    op tacticProof : -> ProofState [ctor] . *** TODO

    *** Projections
    op getProof : ProofState ~> CommentedProof .
    eq getProof(hilbertProof(Proof) ^ ProofState) = Proof .

    op getVariableIndex : ProofState ~> Map{Var,Nat} .
    eq getVariableIndex(ProofState ^ variableIndex(VM)) = VM .

    op getGoal : Nat ProofState ~> Goal .
    eq getGoal(GIndex, ProofState ^ goals(GM ; [GIndex (GI): Goal] ; GM')) = Goal .

    *** Modifiers
    sort ProofStateAndIndex .
    op {_,_} : ProofState Id -> ProofStateAndIndex .
    op getProofState : ProofStateAndIndex -> ProofState .
    eq getProofState({ProofState, Id}) = ProofState .

    op appendProofStep : Claim AMLRule ProofState -> ProofStateAndIndex .
    ceq appendProofStep(Claim, Rule, ProofState ^ hilbertProof(Proof)) =
          {ProofState ^ hilbertProof(Proof'), Id}
      if {Proof', Id} := appendProofStep(Claim, Rule, Proof) .

    op appendAntecedent : Nat Id Pattern ProofState ~> ProofState .
    eq appendAntecedent(GIndex, (WfI), P,
        ProofState ^
        goals(GM ; [GIndex (GI):                          AM |- CM] ; GM'))
      =
        ProofState ^
        goals(GM ; [GIndex (GI): [- fresh(AM) (WfI): P] ; AM |- CM] ; GM') .

    vars N GIndex GI WfI : Nat .
    vars Id : Id .
    var Claim : Claim . var Rule : AMLRule .
    var P : Pattern .
    vars Proof Proof' : CommentedProof .
    var AM : AntecedentMap .
    var CM : ConsequentMap .
    var Goal : Goal .
    vars GM GM' : GoalMap .
    vars VM : Map{Var,Nat} .
    vars PrSt ProofState ProofState' : ProofState .
endm

*** Useful sub-proofs for AML proofs
mod AML-PROOF-LEMMAS is
    pr AML-PROOF-STATE .

    *** Modus Ponens proof step helper function
    vars AntWfId HypWfId ConsequentWfId AntClaimId HypClaimId : Id .
    op modusPonensLemma : Id Id CommentedProof -> ProofAndIndex .
    ceq modusPonensLemma(AntWfId, HypWfId, Proof) =
        { Proof (s getStepNum(Proof)) ConsequentWfId (MP AntClaimId HypClaimId) ; ,
          ConsequentWfId }
      if AntClaimId := getClaimId(AntWfId, Proof)
      /\ HypClaimId := getClaimId(HypWfId, Proof)
      /\ Pi1 HypWfId (\imp AntWfId ConsequentWfId) (WF) ; Pi2 := stripComments(Proof) .

    *** Identity Implication Tautology (P -> P)
    op propILemma : Nat Id -> ProofAndIndex .
    eq propILemma(N, WfId) =
        { (     N) (\imp WfId WfId)        (WF) ; "begin propILemma"
                                                  ***| P -> P
          (1  + N) (\imp WfId (N))         (WF) ; ***| P -> (P -> P)
          (2  + N) (1 + N)              (PropK) ; ***| PropK P P
          (3  + N) (\imp (N) WfId)         (WF) ; ***| (P -> P) -> P
          (4  + N) (\imp WfId (3 + N))     (WF) ; ***| P -> ((P -> P) -> P)
          (5  + N) (4 + N)              (PropK) ; ***| PropK P (P -> P)
          (6  + N) (\imp (1 + N) (N))      (WF) ; ***| (P -> (P -> P)) -> (P -> P)
          (7  + N) (\imp (4 + N) (6 + N))  (WF) ; ***| (P -> ((P -> P) -> P))
                                                  ***  -> ((P -> (P -> P)) -> (P -> P))
          (8  + N) (7 + N)              (PropS) ; ***| PropS P (P -> P) P
          (9  + N) (6 + N) (MP (5 + N) (8 + N)) ; ***| MP 5 8
          (10 + N) (    N) (MP (2 + N) (9 + N)) ; ***| MP 2 9
                                                  "end propILemma"
          , (N) }
        .

    op  wfPatternLemma : Pattern ProofState ~> ProofStateAndIndex .
    eq  wfPatternLemma(P, PrSt ^
          goals(GM ; [N (I): AM ; [- M (WfI): P ] ; AM' |- CM]  ; GM')) =
        {PrSt ^ goals(GM ; [N (I): AM ; [- M (WfI): P ] ; AM' |- CM]  ; GM'),
          (WfI)} .

    eq  wfPatternLemma(bot, PrSt) = {PrSt, (0)} .

    ceq wfPatternLemma(V, variableIndex(VM) ^ PrSt) =
        {variableIndex(VM) ^ PrSt, (M)}
      if M := VM[V] .

    ceq wfPatternLemma(V, variableIndex(VM) ^ hilbertProof(Proof) ^ PrSt) =
        { variableIndex((VM, V |-V> N)) ^
            hilbertProof(Proof (N) getVarType(V) (WF) ; string(getVarName(V))) ^
            PrSt
            , (N) }
      if undefinedVar := VM[V] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ PrSt)  =
        {symbolIndex(SM) ^ PrSt, (M)}
      if M := SM[S] .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ hilbertProof(Proof) ^ PrSt) =
        { symbolIndex((SM, S |-S> N)) ^
            hilbertProof(Proof (N) (\symb) (WF) ; string(pretty(S))) ^
            PrSt
            , (N) }
      if undefinedSym := SM[S] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(exists EV . P, PrSt) =
        appendProofStep((\ex Id1 Id2), (WF), PrSt2)
      if {PrSt', Id1} := wfPatternLemma(EV, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(P, PrSt') .

    ceq wfPatternLemma(mu SV . P, PrSt) =
        appendProofStep((\mu Id1 Id3), (WFMu Id2), PrSt3)
      if {PrSt', Id1} := wfPatternLemma(SV, PrSt)
      /\ {PrSt2, Id2} := nonNegativeLemma(SV, P, PrSt')
      /\ {PrSt3, Id3} := wfPatternLemma(P, PrSt2) .

    ceq wfPatternLemma(P @ P', PrSt) =
        appendProofStep((\app Id1 Id2), (WF), PrSt2)
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(P', PrSt') .

    ceq wfPatternLemma(P --> P', PrSt) =
        appendProofStep((\imp Id1 Id2), (WF), PrSt2)
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(P', PrSt') .

    op wfApplicationContextLemma : Id ApplicationContext ProofState -> ProofStateAndIndex .
    eq wfApplicationContextLemma(VId, [], PrSt) = {PrSt, VId} .
    ceq wfApplicationContextLemma(VId, Ctx @ Q, PrSt) =
        appendProofStep((\app Id1 Id2), (WF),PrSt2)
      if {PrSt', Id1} := wfApplicationContextLemma(VId, Ctx, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(Q, PrSt') .
    ceq wfApplicationContextLemma(VId, P @ Ctx, PrSt) =
        appendProofStep((\app Id1 Id2), (WF),PrSt2)
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt2, Id2} := wfApplicationContextLemma(VId, Ctx, PrSt') .

    *** Side Conditions
    *** #nno : Non negative set variable occurence
    op nonNegativeLemma : SVar Pattern ProofState ~> ProofStateAndIndex .
    ceq nonNegativeLemma(SV, P, PrSt) =
        {PrSt2 ^ hilbertProof(Proof'), NNOId}
      if {PrSt', XId} := wfPatternLemma(SV, PrSt)
      /\ {PrSt2 ^ hilbertProof(Proof) , PId} := wfPatternLemma(P, PrSt)
      /\ {Proof', NNOId} := nonNegativeLemma(XId, PId, Proof) .

    op nonNegativeLemma : Id Id CommentedProof ~> ProofAndIndex .
    eq nonNegativeLemma(XId, (0), Proof) =
        appendProofStep((#nno (0) XId), (NNOBasic), Proof) .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOBasic), Proof)
      if BasicClaim := Proof[PId] .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOImp NPOId NNOId), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', NPOId} := nonPositiveLemma(XId, Id1, Proof)
      /\ {Proof2, NNOId} := nonNegativeLemma(XId, Id2, Proof') .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOApp NNOId1 NNOId2), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', NNOId1} := nonNegativeLemma(XId, Id1, Proof)
      /\ {Proof2, NNOId2} := nonNegativeLemma(XId, Id2, Proof') .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOEx NNOId), Proof')
      if (\ex Id1 Id2) := Proof[PId]
      /\ {Proof', NNOId} := nonNegativeLemma(XId, Id2, Proof) .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOMuBinding), Proof)
      if (\mu XId Id1) := Proof[PId] .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOMuBody NNOId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NNOId} := nonNegativeLemma(XId, Id, Proof) .

    op nonPositiveLemma : Id Id CommentedProof ~> ProofAndIndex .
    eq nonPositiveLemma(XId, (0), Proof) =
        appendProofStep((#npo (0) XId), (NPOBasic), Proof) .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOBasic), Proof)
      if BasicClaim := Proof[PId] /\ XId =/= PId .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOImp NNOId NPOId), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', NNOId} := nonNegativeLemma(XId, Id1, Proof)
      /\ {Proof2, NPOId} := nonPositiveLemma(XId, Id2, Proof') .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOApp NPOId1 NPOId2), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', NPOId1} := nonPositiveLemma(XId, Id1, Proof)
      /\ {Proof2, NPOId2} := nonPositiveLemma(XId, Id2, Proof') .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOEx NPOId), Proof')
      if (\ex Id1 Id2) := Proof[PId]
      /\ {Proof', NPOId} := nonPositiveLemma(XId, Id2, Proof) .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOMuBinding), Proof)
      if (\mu XId Id1) := Proof[PId] .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOMuBody NPOId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NPOId} := nonPositiveLemma(XId, Id, Proof) .

    *** #nf : free variable capture avoidance
    op notFreeLemma : Var Pattern ProofState ~> ProofStateAndIndex .
    ceq notFreeLemma(V, P, PrSt) = {PrSt2 ^ hilbertProof(Proof'), NFId}
      if {PrSt', XId} := wfPatternLemma(V, PrSt)
      /\ {PrSt2 ^ hilbertProof(Proof), PId} := wfPatternLemma(P, PrSt')
      /\ {Proof', NFId} := notFreeLemma(XId, PId, Proof) .

    op notFreeLemma : Id Id CommentedProof ~> ProofAndIndex .
    eq notFreeLemma(XId, (0), Proof) =
        appendProofStep((#nf XId (0)), (NFBasic), Proof) .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFBasic), Proof)
      if BasicClaim := Proof[PId] /\ PId =/= XId .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFImp NFId1 NFId2), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', NFId1} := notFreeLemma(XId, Id1, Proof)
      /\ {Proof2, NFId2} := notFreeLemma(XId, Id2, Proof') .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFApp NFId1 NFId2), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', NFId1} := notFreeLemma(XId, Id1, Proof)
      /\ {Proof2, NFId2} := notFreeLemma(XId, Id2, Proof') .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFExBinding), Proof)
      if (\ex XId Id2) := Proof[PId] .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFExBody NFId), Proof')
      if (\ex YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NFId} := notFreeLemma(XId, Id, Proof) .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFMuBinding), Proof)
      if (\mu XId Id2) := Proof[PId] .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFMuBody NFId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NFId} := notFreeLemma(XId, Id, Proof) .

    *** #subst : Pattern substitution
    op substitutionLemma : Pattern Pattern Pattern Var ProofState ~> ProofStateAndIndex .
    ceq substitutionLemma(R, P, Q, X, PrSt) =
        {PrSt4 ^ hilbertProof(Proof'), SubId}
      if {PrSt', RId} := wfPatternLemma(R, PrSt)
      /\ {PrSt2, PId} := wfPatternLemma(P, PrSt')
      /\ {PrSt3, QId} := wfPatternLemma(Q, PrSt2)
      /\ {PrSt4 ^ hilbertProof(Proof), XId} := wfPatternLemma(X, PrSt3)
      /\ {Proof', SubId} := substitutionLemma(RId, PId, QId, XId, Proof) .

    op substitutionLemma : Id Id Id Id ProofState ~> ProofStateAndIndex .
    ceq substitutionLemma(RId, PId, QId, XId, PrSt ^ hilbertProof(Proof)) =
        {PrSt ^ hilbertProof(Proof'), SubId}
      if {Proof', SubId} := substitutionLemma(RId, PId, QId, XId, Proof) .

    op substitutionLemma : Id Id Id Id CommentedProof ~> ProofAndIndex .

    eq substitutionLemma((0), (0), QId, XId, Proof) =
        appendProofStep((#subst (0) (0) QId XId), (SubstBot), Proof) .

    ceq substitutionLemma(PId, PId, QId, XId, Proof) =
        appendProofStep((#subst PId PId QId XId), (SubstSymb), Proof)
      if Proof[PId] == (\symb) .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstVariable), Proof)
      if Proof[PId] :: VariableClaim /\ (PId == XId and RId == QId) or PId =/= XId  .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstImp SubId1 SubId2), Proof2)
      if (\imp PId1 PId2) := Proof[PId]
      /\ (\imp RId1 RId2) := Proof[RId]
      /\ {Proof', SubId1} := substitutionLemma(RId1, PId1, QId, XId, Proof)
      /\ {Proof2, SubId2} := substitutionLemma(RId2, PId2, QId, XId, Proof') .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstApp SubId1 SubId2), Proof2)
      if (\app PId1 PId2) := Proof[PId]
      /\ (\app RId1 RId2) := Proof[RId]
      /\ {Proof', SubId1} := substitutionLemma(RId1, PId1, QId, XId, Proof)
      /\ {Proof2, SubId2} := substitutionLemma(RId2, PId2, QId, XId, Proof') .

    ceq substitutionLemma(PId, PId, QId, XId, Proof) =
        appendProofStep((#subst PId PId QId XId), (SubstExBinding), Proof)
      if (\ex XId RId) := Proof[PId] .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep(
          (#subst RId PId QId XId),
          (SubstExBody FVId NFId SubId1 SubId2),
          Proof4)
      if (\ex YId PId1) := Proof[PId] /\ YId =/= XId
      /\ (\ex FVId RId2) := Proof[RId] /\ FVId =/= XId
      /\ {Proof', NFId} := notFreeLemma(FVId, QId, Proof)
      /\ {Proof2, RId1} := wfSubstitutionLemma(PId1, FVId, YId, Proof')
      /\ {Proof3, SubId1} := substitutionLemma(RId1, PId1, FVId, YId, Proof2)
      /\ {Proof4, SubId2} := substitutionLemma(RId2, RId1, QId, XId, Proof3) .

    ceq substitutionLemma(PId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstMuBinding), Proof)
      if (\mu XId RId) := Proof[PId] .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep(
          (#subst RId PId QId XId),
          (SubstMuBody FVId NFId SubId1 SubId2),
          Proof4)
      if (\mu YId PId1) := Proof[PId] /\ YId =/= XId
      /\ (\mu FVId RId2) := Proof[RId] /\ FVId =/= XId
      /\ {Proof', NFId} := notFreeLemma(FVId, QId, Proof)
      /\ {Proof2, RId1} := wfSubstitutionLemma(PId1, FVId, YId, Proof')
      /\ {Proof3, SubId1} := substitutionLemma(RId1, PId1, FVId, YId, Proof2)
      /\ {Proof4, SubId2} := substitutionLemma(RId2, RId1, QId, XId, Proof3) .

    op wfSubstitutionLemma : Id Id Id ProofState -> ProofStateAndIndex .
    ceq wfSubstitutionLemma(PId, QId, XId, PrSt ^ hilbertProof(Proof)) =
        {PrSt ^ hilbertProof(Proof'), WfId}
      if {Proof', WfId} := wfSubstitutionLemma(PId, QId, XId, Proof) .

    op wfSubstitutionLemma : Id Id Id CommentedProof -> ProofAndIndex .
    eq wfSubstitutionLemma((0), QId, XId, Proof) = {Proof, (0)} .
    eq wfSubstitutionLemma(XId, QId, XId, Proof) = {Proof, QId} .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) = {Proof, PId}
      if Proof[PId] :: BasicClaim /\ PId =/= XId .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\imp SubId1 SubId2), (WF), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', SubId1} := wfSubstitutionLemma(Id1, QId, XId, Proof)
      /\ {Proof2, SubId2} := wfSubstitutionLemma(Id2, QId, XId, Proof') .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\app SubId1 SubId2), (WF), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', SubId1} := wfSubstitutionLemma(Id1, QId, XId, Proof)
      /\ {Proof2, SubId2} := wfSubstitutionLemma(Id2, QId, XId, Proof') .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) = {Proof, PId}
      if (\ex XId Id) := Proof[PId] .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\ex YId SubId), (WF), Proof')
      if (\ex YId Id) := Proof[PId]
      /\ {Proof', SubId} := wfSubstitutionLemma(Id, QId, XId, Proof) .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) = {Proof, PId}
      if (\mu XId Id) := Proof[PId] .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\ex YId SubId), (WFMu NNOId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ {Proof', SubId} := wfSubstitutionLemma(Id, QId, XId, Proof)
      /\ {Proof2, NNOId} := nonNegativeLemma(YId, Id, Proof') .

    *** #appctx Application context pattern side conditions
    op applicationContextLemma : ApplicationContext ProofState ~> ProofStateAndIndex .
    ceq applicationContextLemma(Ctx, PrSt) =
        applicationContextLemma(VId, Ctx, PrSt')
      if {PrSt', VId} := appendProofStep((\evar), (WF), PrSt) .

    op applicationContextLemma : Id ApplicationContext ProofState ~> ProofStateAndIndex .
    ceq applicationContextLemma(VId, Ctx, PrSt) =
        {PrSt2 ^ hilbertProof(Proof'), ACId}
      if {PrSt', WfId} := wfApplicationContextLemma(VId, Ctx, PrSt)
      /\ PrSt2 ^ hilbertProof(Proof) := PrSt'
      /\ {Proof', ACId} := applicationContextLemma(VId, Ctx, WfId, Proof) .

    op applicationContextLemma : Id ApplicationContext Id CommentedProof ~> ProofAndIndex .

    eq applicationContextLemma(VId, [], VId, Proof) =
        appendProofStep((#appctx VId VId), (AppCtxInit), Proof) .

    ceq applicationContextLemma(VId, Ctx @ Q, Id, Proof) =
        appendProofStep((#appctx Id VId), (AppCtxL ACId NFId), Proof2)
      if (\app CtxId QId) := Proof[Id]
      /\ {Proof', NFId} := notFreeLemma(VId, QId, Proof)
      /\ {Proof2, ACId} := applicationContextLemma(VId, Ctx, CtxId, Proof') .

    ceq applicationContextLemma(VId, P @ Ctx, Id, Proof) =
        appendProofStep((#appctx Id VId), (AppCtxR ACId NFId), Proof2)
      if (\app PId CtxId) := Proof[Id]
      /\ {Proof', NFId} := notFreeLemma(VId, PId, Proof)
      /\ {Proof2, ACId} := applicationContextLemma(VId, Ctx, CtxId, Proof') .

    vars N N' N2 N3 M M' I WfI : Nat .
    vars Id Id1 Id2 Id3 WfId : Id .
    vars NNOId NNOId1 NNOId2 : Id .
    vars NPOId NPOId1 NPOId2 : Id .
    vars NFId NFId1 NFId2 : Id .
    vars SubId SubId1 SubId2 : Id .
    vars ACId : Id .
    vars PId PId1 PId2 QId RId RId1 RId2 VId XId YId FVId CtxId : Id .
    var S : Symbol .
    vars P P' Q R Sub : Pattern .
    vars Ctx Ctx1 Ctx2 : ApplicationContext .
    vars X V : Var . var EV : EVar . var SV : SVar .
    var VarClaim : VariableClaim .
    var BasicClaim : BasicClaim .
    var Claim : Claim . var Rule : AMLRule .
    vars Proof Proof' Proof2 Proof3 Proof4 Pi1 Pi2 : CommentedProof .
    vars SM SM' : Map{Symbol,Nat} . vars VM VM' : Map{Var,Nat} .
    vars GM GM' : GoalMap . vars AM AM' : AntecedentMap . var CM : ConsequentMap .
    vars PrSt PrSt' PrSt2 PrSt3 PrSt4 : ProofState .
endm

mod AML-PROOF-STATE-TRANSITIONS is
    inc AML-PROOF-STATE .
    inc AML-PROOF-LEMMAS .

    op initializeProofState : PatternList Pattern -> ProofState .
    eq initializeProofState(Assumptions, Conclusion) =
        tacticProof
        ^ hilbertProof((0) (\bot) (WF) ;)
        ^ goalCounter(1)
        ^ symbolIndex(empty)
        ^ variableIndex(empty)
        ^ goals(
          [ 0 (0):
            mt |- [ 0 (0): makeClaim(Assumptions,Conclusion) ]
            ]
          )
        .

    *** GoalMap precondition
    crl [gmPre] : goals([N (I): G] ; GM ) => goals([0 (I): G] ; GM) if N > 0 .

    vars N I : Nat .
    var Conclusion : Pattern . var Assumptions : PatternList .
    var G : Goal . var GM : GoalMap .
endm

mod AML-JUDGEMENTS is including AML-PROOF-STATE-TRANSITIONS .
*** The rewrite rules in this module define the proof rules,
*** judgments, and tactics for interactive AML Proofs
*** Every rule should be labelled and marked `nonexec`
*** since they will be `metaApply`ed by the applyCommand
*** equation to enable pattern matching and substitution
*** preprocessing as well as descriptive error messages .

***********************
*** AML Proof Rules ***
***********************

    *** Introduce Axiom with no side conditions
    op axiomIntroRule : Nat Pattern AMLRule ProofState ~> ProofState .
    ceq axiomIntroRule(GIndex, Axiom, Rule, ProofState)  =
        appendAntecedent(GIndex, WfId, Axiom, ProofState2)
      if {ProofState', WfId} := wfPatternLemma(Axiom, ProofState)
      /\ {ProofState2, ClaimId} := appendProofStep(WfId, Rule, ProofState') .

    *** Modus Ponens Inference Rule
    crl [modusPonens] :
        hilbertProof(Proof) ^
        goals(GM ;
          [ GIndex (GI):
            AM1 ; [- L (WfIHyp): Antecedent --> Consequent ] ;
            AM2 ; [- M (WfIAnt): Antecedent ] ;
            AM3
            |- CM ] ;
          GM')
      =>
        hilbertProof(Proof') ^
        goals(GM ;
          [ GIndex (GI):
                  [- fresh(AM1) (WfICon):       Consequent ] ;
            AM1 ; [- L (WfIHyp): Antecedent --> Consequent ] ;
            AM2 ; [- M (WfIAnt): Antecedent ] ;
            AM3
            |- CM ] ;
          GM')
      if {Proof', (WfICon)} := modusPonensLemma((WfIAnt), (WfIHyp), Proof)
      [nonexec] .

    *** ∃-Quantifier
    *** RHS Free Variables
    *** - `P` Pattern to be quantified
    *** - `EVar` free variable to quantify pattern
    *** - `GIndex` goal index to modify
    crl [exQuant] :
        ProofState =>
        appendAntecedent(GIndex, WfId, P --> (exists EVar . P), PrState4)
      if {PrState', PWfId} := wfPatternLemma(P, ProofState)
      /\ {PrState2, WfId} := wfPatternLemma(P --> (exists EVar . P), PrState')
      /\ ExVI := getVariableIndex(PrState2)[EVar]
      /\ {PrState3 ^ hilbertProof(Proof), FVId} := appendProofStep((\evar), (WF), PrState2)
      /\ {Proof', SubId} := substitutionLemma(PWfId, PWfId, FVId, (ExVI), Proof)
      /\ {PrState4, ClaimId} :=
              appendProofStep(WfId, (ExistsQ SubId), PrState3 ^ hilbertProof(Proof'))
      [nonexec] .

    *** ∃-Generalization
    op exGenRule : Nat EVar Pattern Pattern ProofState ~> ProofState .
    ceq exGenRule(GIndex, EVar, Antecedent, Consequent, ProofState) =
        appendAntecedent(GIndex, WfId,
            (exists EVar . Antecedent) --> Consequent, PrState2)
      if AM ; [- N (WfIHyp): Antecedent --> Consequent ] ; AM' |- CM
         := getGoal(GIndex, ProofState)
      /\ {PrState' ^ hilbertProof(Proof), WfId} := wfPatternLemma(
            (exists EVar . Antecedent) --> Consequent, ProofState)
      /\ ExVI := getVariableIndex(PrState')[EVar]
      /\ ClaimId := getClaimId((WfIHyp), Proof)
      /\ (\imp PId QId) := Proof[((WfIHyp)).Id]
      /\ {Proof', NFId} := notFreeLemma(((ExVI)).Id, QId, Proof)
      /\ {PrState2, Id} :=
          appendProofStep(WfId,
            (ExistsR ClaimId NFId),
            PrState' ^ hilbertProof(Proof')) .

***************************
*** Derived Proof Rules ***
***************************

*** Identity Tautology P --> P
*** RHS Free Variables:
*** - `IdPattern` instantiating Pattern
    crl [propI] :
        ProofState
      =>
        ProofState' ^
        hilbertProof(Proof' Proof2) ^
        goals(GM ; [GIndex (N): [- fresh(AM) (I): IdPattern --> IdPattern] ; AM |- CM ] ; GM')
      if hilbertProof(Proof) ^
         variableIndex(VM) ^ symbolIndex(SM) ^
         goals(GM ; [GIndex (N): AM |- CM ] ; GM') ^
         PrState := ProofState
      /\ { ProofState' ^
           goals(GM ; [GIndex (N): AM |- CM ] ; GM') ^
           hilbertProof(Proof'),
           WfId
         } := wfPatternLemma(IdPattern, ProofState)
      /\ {Proof2, (I)} := propILemma(s getStepNum(Proof'), WfId) [nonexec] .

******************************
*** Sequent Calculus Rules ***
******************************

    *** Assert that a goal is proved
    rl [axiom] :
        hilbertProof(Proof) ^
        goals(GM ; [GIndex (I): AM1 ; [- N (WfI): P] ; AM2 |- CM1 ; [M (I2): P] ; CM2] ; GM')
      =>
        hilbertProof(Proof) ^
        goals(GM ; [GIndex (I): proved(P, (WfI), getClaimId((WfI), Proof))] ; GM')
        [nonexec] .

    vars K L M N I I1 I2 GI WfI KWfI SWfI WfIAnt WfIHyp WfICon GIndex ExVI : Nat .
    vars Id Id' WfId WfId' PId PWfId QId QWfId RWfId HypId ClaimId FVId SubId NFId : Id .
    var Rule : AMLRule .
    vars Proof Proof' Proof2 Pi1 Pi2 PrSt : CommentedProof .
    var V : Var . var EVar : EVar .
    vars P Q R Axiom Antecedent Hypothesis Consequent Conclusion IdPattern : Pattern .
    vars PS Assumptions : PatternSet .
    vars S : Symbol .
    vars SM SM' : Map{Symbol,Nat} . vars VM VM' : Map{Var,Nat} .
    vars GM GM' : GoalMap . vars AM AM' AM1 AM2 AM3 : AntecedentMap .
    vars CM CM1 CM2 : ConsequentMap .
    vars ProofState ProofState' ProofState2 ProofState3 : ProofState .
    vars PrState PrState' PrState2 PrState3 PrState4 : ProofState .

endm

fmod SUBSTITUTION is pr META-LEVEL' .
***  Take a Substitution, Like one from a metaXmatch result,
*** and instantiate the matched term.
*** This helps with AML-Pattern Pattern matching in prover commands
    op applySubstitution : Term     Substitution -> Term .
    op applySubstitution : TermList Substitution -> TermList .

    eq applySubstitution(Con, Sub) = Con .

    eq applySubstitution(Var, Var <- T ; Sub) = T .
    eq applySubstitution(Var, Sub) = Var [owise] .

    eq applySubstitution(Operator[Args], Sub) =
        Operator[applySubstitution(Args, Sub)] .

    eq applySubstitution(empty, Sub) = empty .
    eq applySubstitution((T ~ Ts), Sub) =
        applySubstitution(T, Sub) ~ applySubstitution(Ts, Sub) .

    var Var : Variable .
    var Con : Constant .
    var T : Term . var Ts : NeTermList .
    var Operator : Qid .
    vars Args : TermList .
    var Sub : Substitution .
endfm

mod AML-PROVER-COMMANDS is including AML-PROOF-STATE-TRANSITIONS .
    inc AML-JUDGEMENTS .
    protecting INT .
    protecting PRINT-AML-GOAL .
    protecting AML-GOAL .
    protecting AML-USER-THEORY .

    protecting LOOP-MODE .
    protecting SUBSTITUTION .
    protecting PRETTY .
    sorts Tactic MLRule ProverCMD .

*************************
*** Basic UI Commands ***
*************************
    op noop : -> ProverCMD [ctor] .

    sort EmptyProofCMD . subsort EmptyProofCMD < ProverCMD .
    op begin`proof`of_assuming_ : Pattern PatternList -> EmptyProofCMD [ctor gather (& E)] .
    op begin`proof`of_ : Pattern -> ProverCMD [prec 42] .
    eq begin proof of P = begin proof of P assuming nil .

    op sg_ : Nat -> ProverCMD [ctor] .
    op switch`goal_ : Nat -> ProverCMD .
    eq switch goal N:Nat = sg N:Nat .

    op pp : -> ProverCMD [ctor] .
    op print`proof : -> ProverCMD .
    eq print proof = pp .

    op pg : -> ProverCMD [ctor] .
    op print`goal : -> ProverCMD .
    eq print goal = pg .

    op pgs : -> ProverCMD [ctor] .
    op print`goals : -> ProverCMD .
    eq print goals = pgs .

    op cp : -> ProverCMD [ctor] .
    op check`proof : -> ProverCMD .
    eq check proof = cp .

    op dp : -> ProverCMD [ctor] .
    op dump`proof : -> ProverCMD .
    eq dump`proof = dp .

*******************************
*** AML Proof Rule Commands ***
*******************************

    *** Specialize ProverCMD errors when patterns are malformed
    sort PatternProverCMD .
    subsort PatternProverCMD < ProverCMD .

    *** Prop Κ:
    ***  Γ |- Δ
    *** ---------------------
    ***  Γ, P -> Q -> P |- Δ
    op K__ : Pattern Pattern -> PatternProverCMD [ctor prec 42] .
    op propK__ : Pattern Pattern -> PatternProverCMD [prec 42].
    eq propK P Q = K P Q .

    *** Prop S:
    ***  Γ |- Δ
    *** -------------------------------------------------
    ***  Γ, (P -> (Q -> R)) -> (P -> Q) -> (P -> R) |- Δ
    op S___ : Pattern Pattern Pattern -> PatternProverCMD [ctor prec 42] .
    op propS___ : Pattern Pattern Pattern -> PatternProverCMD [prec 42].
    eq propS P Q R = S P Q R .

    *** Prop F:
    ***  Γ |- Δ
    *** ----------------------------------
    ***  Γ, ((P -> _|_) -> _|_) -> P |- Δ
    op F_ : Pattern -> PatternProverCMD [ctor prec 42] .
    op propF_ : Pattern -> PatternProverCMD .
    eq propF P = F P .

    *** Modus Ponens:
    ***  Γ, P, P -> Q |- Δ
    *** ----------------------
    ***  Γ, P, P -> Q, Q |- Δ
    op mp__ : Pattern Pattern -> ProverCMD [ctor] .
    op modus`ponens__ : Pattern Pattern -> ProverCMD [ctor] .
    eq modus ponens P Q  = mp P Q .

    *** ∃ - Quantifier:
    ***  Γ |- Δ
    *** ---------------------- [ if not (x ∈ FV(P)) ]
    ***  Γ, P -> ∃ x . P |- Δ
    op eq__ : Qid Pattern -> PatternProverCMD [ctor] .
    op existential`quantifier__ : Qid Pattern -> PatternProverCMD .
    eq existential quantifier Q:Qid P = eq Q:Qid P .

    *** ∃ - Generalization:
    ***  Γ, P -> Q |- Δ
    *** ---------------------- [ if not (x ∈ FV(Q)) ]
    ***  Γ, ∃ x . P -> Q |- Δ
    op eg___ : Qid Pattern Pattern -> ProverCMD [ctor] .
    op existential`generalization___ : Qid Pattern Pattern -> ProverCMD .
    eq existential generalization Q:Qid P Q = eg Q:Qid P Q .

    *** Propagation-_|_
    ***  Γ |- Δ
    *** ------------------------
    ***  Γ, C[_|_] --> _|_ |- Δ
    op lbp_ : Pattern -> PatternProverCMD [ctor] .
    op left`bot`propagation_ : Pattern -> PatternProverCMD .
    eq left bot propagation P = lbp P .

    op rbp_ : Pattern -> PatternProverCMD [ctor] .
    op right`bot`propagation_ : Pattern -> PatternProverCMD .
    eq right bot propagation P = rbp P .

    *** Propagation-\/
    ***  Γ |- Δ
    *** ------------------------------------
    ***  Γ, C[P \/ Q] --> C[P] \/ C[Q] |- Δ
    op lop___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op left`or`propagation___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq left or propagation C:Pattern P Q = lop C:Pattern P Q .

    op rop___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op right`or`propagation___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq right or propagation C:Pattern P Q = rop C:Pattern P Q .

    *** Propagation-∃
    ***  Γ |- Δ
    *** ----------------------------------- [if x not in FV(C)]
    ***  Γ, C[∃ x . P] --> ∃ x . C[P] |- Δ
    op lep___ : Pattern EVar Pattern -> PatternProverCMD [ctor] .
    op left`existential`propagation___ : Pattern EVar Pattern -> PatternProverCMD .
    eq left existential propagation C:Pattern EVar P = lep C:Pattern EVar P .

    op rep___ : Pattern EVar Pattern -> PatternProverCMD [ctor] .
    op right`existential`propagation___ : Pattern EVar Pattern -> PatternProverCMD .
    eq right existential propagation C:Pattern EVar P = rep C:Pattern EVar P .

    *** Framing
    *** Γ, P --> Q |- Δ
    *** -----------------
    *** Γ, C[P] --> C[Q] |- Δ
    op lfr___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op left`framing___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq left framing C:Pattern P Q = lfr C:Pattern P Q .

    op rfr___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op right`framing___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq right framing C:Pattern P Q = rfr C:Pattern P Q .

    *** Set Variable Substitution
    ***  Γ, P |- Δ
    *** ----------------
    ***  Γ, P[Q/X] |- Δ
    op svs___ : Qid Pattern Pattern -> PatternProverCMD [ctor] .
    op set`variable`substitution___ : Qid Pattern Pattern -> PatternProverCMD .
    eq set variable substitution X:Qid P Q = svs X:Qid P Q .

    *** Pre-fixpoint
    ***  Γ |- Δ
    *** ---------------------------------
    ***  Γ P[μ X . P/X] --> μ X . P |- Δ
    op pfp__ : Qid Pattern -> PatternProverCMD [ctor] .
    op pre`fixpoint__ : Qid Pattern -> PatternProverCMD .
    eq pre fixpoint X:Qid P = pfp X:Qid P .

    *** Knaster-Tarski
    ***  Γ,  P[Q/X] --> Q |- Δ
    *** -----------------------
    ***  Γ, μ X . P --> Q |- Δ
    op kt___ : Qid Pattern Pattern -> PatternProverCMD [ctor] .
    op knaster`tarski___ : Qid Pattern Pattern -> PatternProverCMD .
    eq knaster tarski X:Qid P Q = kt X:Qid P Q .

    *** Existence
    ***  Γ |- Δ
    *** ------------------
    ***  Γ, ∃ x . x, |- Δ
    op ex_ : Qid -> ProverCMD [ctor] .
    op existence_ : Qid -> ProverCMD .
    eq existence Q:Qid = ex Q:Qid .

    *** Singleton
    *** Γ |- Δ
    *** ------------------------------------
    *** Γ, ~ (C1[x /\ P ] /\ C2[x /\ ~ P])
    op sng____ : ApplicationContext ApplicationContext Qid Pattern -> PatternProverCMD [ctor] .
    op singleton____ : ApplicationContext ApplicationContext Qid Pattern -> PatternProverCMD .
    eq singleton Ctx1 Ctx2 Q:Qid P = sng Ctx1 Ctx2 Q:Qid P .

***************************
*** Derived Proof Rules ***
***************************

    *** Identity Tautology:
    ***  Γ |- Δ
    *** --------
    ***  Γ, P -> P |- Δ
    op I_ : Pattern -> PatternProverCMD [ctor prec 42] .
    op propI_ : Pattern -> PatternProverCMD [prec 42] .
    eq propI P = I P .

******************************
*** Sequent Calculus Rules ***
******************************

    *** Axiom:
    *** ----------
    ***  Γ, ax |- ax, Δ
    op ax : -> ProverCMD [ctor] .
    op axiom : -> ProverCMD .
    eq axiom = ax .

**********************************
*** Prover Command Application ***
    sort CommandResult .
    subsort ProofState QidList < CommandResult .
    op <_#_> : ProofState QidList -> CommandResult [ctor] .
    op noProof : -> CommandResult [ctor] .
    op applyCommand : ProverCMD ProofState -> CommandResult .

*************************
*** Basic UI Commands ***
*************************

    *** Initiate prover loop
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, .ProofState) =
        initializeProofState(Hypotheses, Conclusion) .

    *** Do not overwrite proof with `begin proof`
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, ProofState) =
        ''begin 'proof' 'will 'overwrite 'current 'proof '\n
        'please ''dump 'proof' 'and 'try 'again '\n [owise] .

    *** Empty ProofState
    ceq applyCommand(CMD:ProverCMD, .ProofState) = noProof
      if not (CMD:ProverCMD :: EmptyProofCMD) .

    *** Print Goals
    eq applyCommand(pgs, goals(GM) ^ ProofState) = pretty(GM) .

    *** Check Proof
    ceq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
        'Invalid 'Proof 'Index
      if not check-id(Proof) .

    ceq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
        'Proof 'is 'Valid
      if check-step(Proof) [owise] .

    eq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
        metaPrettyPrint(['AML-CHECKER], upTerm(check-step(Proof))) [owise] .

    *** Print Proof
    eq applyCommand(pp, hilbertProof(CommentedProof) ^ ProofState) =
        metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) .

    *** Print proof and start over
    eq applyCommand(dp, hilbertProof(CommentedProof) ^ ProofState) =
        < .ProofState # metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) > .

    eq applyCommand(pg, goals([0 (I): G] ; GM) ^ ProofState) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G))  .

***********************
*** AML Proof Rules ***
***********************

    *** PropK
    eq applyCommand(K P Q, ProofState) =
        axiomIntroRule(0, P --> Q --> P, (PropK), ProofState) .

    *** PropS
    eq applyCommand(S P Q R, ProofState) =
        axiomIntroRule(0, (P --> Q --> R) --> (P --> Q) --> (P --> R),
          (PropS), ProofState) .

    *** PropF
    eq applyCommand(F P, ProofState) =
        axiomIntroRule(0, ((P --> bot) --> bot) --> P, (PropF), ProofState) .

    *** Modus Ponens
    ceq applyCommand(mp Ant Con, ProofState) = ProofState'
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' := amlPatternMatch(
            Ant --> Con,
            upTerm(AM),
            *** Meta-matching side-condition:
            ***     Ant must be an antecedent pattern
            '_;_['AM1:AntecedentMap
              ~ ('`[-_`(_`):_`]['N:Nat ~ 'I:Nat ~ 'Ant:Pattern])
              ~ 'AM2:AntecedentMap]
            := upTerm(AM))
      /\ ProofState' := applyRule(ProofState, 'modusPonens,
            'GIndex:Nat <- upTerm(0) ;
            'Antecedent:Pattern <- upTerm(Ant') ;
            'Consequent:Pattern <- upTerm(Con') ) .

    eq applyCommand(mp Ant Con, ProofState) =
        'Modus 'Ponens 'failed [owise] .

    *** ∃-Quantification Axiom
    ceq applyCommand(eq Q:Qid P, ProofState) =
        'Existential 'quantification 'failed '\n
        Q:Qid 'occurs 'free 'in 'pattern
      if isFreeIn(evar(Q:Qid), P) .

    eq applyCommand(eq Q:Qid P, ProofState) =
        applyRule(ProofState, 'exQuant,
          'GIndex:Nat <- '0.Zero ;
          'P:Pattern <- upTerm(P) ;
          'EVar:EVar <- upTerm(evar(Q:Qid)))
          [owise] .

    *** ∃-Generalization Inference Rule
    ceq applyCommand(eg Q:Qid Ant Con, ProofState) = ProofState'
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' := amlPatternMatch(Ant --> Con, upTerm(AM),
            'false.Bool := 'isFreeIn[('evar[upTerm(Q:Qid)]) ~ upTerm(Ant)])
      /\ ProofState' := exGenRule(0, evar(Q:Qid), Ant', Con', ProofState) .

    eq applyCommand(eg Q:Qid Ant Con, ProofState) =
        'Existential 'Generalization 'failed [owise] .

    *** Propagation-_|_
    eq applyCommand(lbp P, ProofState) =
        axiomIntroRule(0, bot @ P --> bot, (PropagationBotL), ProofState) .

    eq applyCommand(rbp P, ProofState) =
        axiomIntroRule(0, P @ bot --> bot, (PropagationBotR), ProofState) .

    *** Propagation-\/
    eq applyCommand(lop C:Pattern P Q, ProofState) =
        axiomIntroRule(0,
          (P \/ Q) @ C:Pattern --> ((P @ C:Pattern) \/ (Q @ C:Pattern)),
          (PropagationOrL), ProofState) .

    eq applyCommand(rop C:Pattern P Q, ProofState) =
        axiomIntroRule(0,
           C:Pattern @ (P \/ Q) --> ((C:Pattern @ P) \/ (C:Pattern @ Q)),
          (PropagationOrR), ProofState) .

    *** Propagation-∃
    ceq applyCommand(lep C:Pattern EVar P, ProofState) =
        axiomIntroRule(0,
          (exists EVar . P) @ C:Pattern --> (exists EVar . P @ C:Pattern),
          (PropagationExL NFId), ProofState')
      if {ProofState', NFId} := notFreeLemma(EVar, C:Pattern, ProofState) .

    ceq applyCommand(rep C:Pattern EVar P, ProofState) =
        axiomIntroRule(0,
          C:Pattern @ (exists EVar . P) --> (exists EVar . C:Pattern @ P),
          (PropagationExR NFId), ProofState')
      if {ProofState', NFId} := notFreeLemma(EVar, C:Pattern, ProofState) .

    *** Framing
    ceq applyCommand(lfr C:Pattern Ant Con, ProofState) =
        axiomIntroRule(0, Ant' @ C:Pattern --> Con' @ C:Pattern, (FrameL ClaimId),
          ProofState)
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' := amlPatternMatch(Ant --> Con, upTerm(AM))
      /\ AM1 ; [- N (WfI): Ant' --> Con'] ; AM2 := AM
      /\ ClaimId := getClaimId((WfI), getProof(ProofState)) .

    ceq applyCommand(rfr C:Pattern Ant Con, ProofState) =
        axiomIntroRule(0, C:Pattern @ Ant' --> C:Pattern @ Con', (FrameR ClaimId),
          ProofState)
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' := amlPatternMatch(Ant --> Con, upTerm(AM))
      /\ AM1 ; [- N (WfI): Ant' --> Con'] ; AM2 := AM
      /\ ClaimId := getClaimId((WfI), getProof(ProofState)) .

    *** set variable substitution
    ceq applyCommand(svs X:Qid Hyp Q, ProofState) =
        appendAntecedent(0, WfId, Conclusion, PrSt5)
      if SVar := svar(X:Qid)
      /\ AM |- CM := getGoal(0, ProofState)
      /\ Hyp' := amlPatternMatch(Hyp, upTerm(AM), upTerm(Hyp[Q / SVar]) : 'Pattern)
      /\ AM1 ; [- N (WfI): Hyp'] ; AM2 := AM
      /\ {PrSt1, XId} := wfPatternLemma(SVar,ProofState)
      /\ {PrSt2, QId} := wfPatternLemma(Q, PrSt1)
      /\ Conclusion := Hyp'[Q / SVar]
      /\ {PrSt3, WfId} := wfPatternLemma(Conclusion, PrSt2)
      /\ {PrSt4, SubId} := substitutionLemma(WfId, (WfI), QId, XId, PrSt3)
      /\ ClaimId := getClaimId((WfI), getProof(PrSt4))
      /\ {PrSt5, Id} :=
          appendProofStep(WfId, (SVarSubst (ClaimId) SubId), PrSt4) .

    eq applyCommand(svs X:Qid Hyp Q, ProofState) =
        'Set 'Variable 'Substitution 'failed '\n
        'Check 'that 'substitution 'avoids 'alpha 'capture
        [owise] .

    *** Pre-Fixpoint
    ceq applyCommand(pfp X:Qid P, ProofState) =
        appendAntecedent(0, WfId, R --> Q, PrSt5)
      if SVar := svar(X:Qid)
      /\ Q := mu SVar . P
      /\ R := P[mu SVar . P / SVar]
      /\ {PrSt, PId} := wfPatternLemma(P, ProofState)
      /\ {PrSt1, QId} := wfPatternLemma(Q, PrSt)
      /\ {PrSt2, RId} := wfPatternLemma(R, PrSt1)
      /\ XId := (getVariableIndex(PrSt2)[SVar])
      /\ {PrSt3, SubId} := substitutionLemma(RId, PId, QId, XId, PrSt2)
      /\ {PrSt4, WfId} := wfPatternLemma(R --> Q, PrSt3)
      /\ {PrSt5, ClaimId} := appendProofStep(WfId, (Prefixpoint SubId), PrSt4) .

    eq applyCommand(pfp X:Qid P, ProofState) =
        'Pre-fixpoint 'failed '\n
        'Check 'that 'substitution 'avoids 'alpha 'capture
        [owise] .

    *** Knaster-Tarski
    ceq applyCommand(kt X:Qid P Con, ProofState) =
        appendAntecedent(0, WfId, Conclusion, PrSt3)
      if SVar := svar(X:Qid)
      /\ AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' :=
          amlPatternMatch(
              '_-->_['Ant:Pattern ~ upTerm(Con)],
              upTerm(AM),
              'Ant:Pattern := upTerm(P[Con / SVar]))
      /\ AM1 ; [- N (WfI): Ant' --> Con'] ; AM2 := AM
      /\ ClaimId := getClaimId((WfI), getProof(ProofState))
      /\ (\imp RId QId) := getProof(ProofState)[((WfI)).Id]
      /\ Conclusion := (mu SVar . P) --> Con'
      /\ {PrSt1, WfId} := wfPatternLemma(Conclusion, ProofState)
      /\ (\imp Id QId) := getProof(PrSt1)[WfId]
      /\ (\mu XId PId) := getProof(PrSt1)[Id]
      /\ {PrSt2, SubId} := substitutionLemma(RId, PId, QId, XId, PrSt1)
      /\ {PrSt3, (I)} := appendProofStep((WfId), (KT ClaimId SubId), PrSt2) .

    eq applyCommand(kt X:Qid PreP Q, ProofState) =
        'Knaster-Tarksi 'failed '\n
        'check 'that 'pattern 'argument 'is  'correct 'substitution
        [owise] .

    *** Existence Axiom
    eq applyCommand(ex Q:Qid, ProofState) =
        axiomIntroRule(0, exists evar(Q:Qid) . evar(Q:Qid), (Existence),
          ProofState) .

    *** Singleton Axiom
    *** let Q := x /\ P    == (x -> (P -> _|_)) -> _|_
    ***     R := x /\ ~ P  == (x -> P) -> _|_
    *** C1[Q] -> (C2[R] -> bot)
    ceq applyCommand(sng Ctx1 Ctx2 Q:Qid P, ProofState) =
        appendAntecedent(0, WfId, (Ctx1[Q]) --> (Ctx2[R]) --> bot, PrSt11)
      if EVar := evar(Q:Qid)
      /\ Q := ~ (EVar --> ~ P)
      /\ R := ~ (EVar -->   P)
      /\ {PrSt, QId} := wfPatternLemma(Q, ProofState)
      /\ {PrSt1, RId} := wfPatternLemma(R, PrSt)
      /\ {PrSt2, FVId} := appendProofStep((\evar), (WF), PrSt1)
      /\ {PrSt3, ACId1} := applicationContextLemma(FVId, Ctx1, PrSt2)
      /\ {PrSt4, ACId2} := applicationContextLemma(FVId, Ctx2, PrSt3)
      /\ (#appctx CId1 FVId) := getProof(PrSt4)[ACId1]
      /\ (#appctx CId2 FVId) := getProof(PrSt4)[ACId2]
      /\ {PrSt5, ResId1} := wfSubstitutionLemma(CId1, QId, FVId, PrSt4)
      /\ {PrSt6, ResId2} := wfSubstitutionLemma(CId2, RId, FVId, PrSt5)
      /\ {PrSt7, SubId1} := substitutionLemma(ResId1, CId1, QId, FVId, PrSt6)
      /\ {PrSt8, SubId2} := substitutionLemma(ResId2, CId2, RId, FVId, PrSt7)
      /\ {PrSt9, Id} := appendProofStep((\imp ResId2 (0)), (WF), PrSt8)
      /\ {PrSt10, WfId} := appendProofStep((\imp ResId1 Id), (WF), PrSt9)
      /\ {PrSt11, ClaimId} :=
        appendProofStep(WfId, (Singleton ACId1 SubId1 ACId2 SubId2), PrSt10) .

    eq applyCommand(sng Ctx1 Ctx2 Q:Qid P, ProofState) =
        'Singleton 'command 'failed [owise] .

***************************
*** Derived Proof Rules ***
***************************

    *** PropI
    eq applyCommand(I P, ProofState) =
        applyRule(ProofState, 'propI,
          'GIndex:Nat <- upTerm(0) ;
          'IdPattern:Pattern <- upTerm(P)) .

******************************
*** Sequent Calculus Rules ***
******************************

    *** AXIOM
    ceq applyCommand(ax, ProofState) = ProofState'
      if ProofState' :=
          applyRule(ProofState, 'axiom, 'GIndex:Nat <- upTerm(0)) .

    eq applyCommand(ax, ProofState) =
        'No 'match 'for 'AXIOM 'judgement [owise] .

    eq applyCommand(CMD:ProverCMD, ProofState) =
        'Command 'not 'implemented 'yet [owise] .
*** Helper Functions
    *** Apply a rule contained in the AML-JUDGEMENTS module
    sort JudgementResult .
    subsort ProofState < JudgementResult .
    op failure : -> JudgementResult [ctor] .
    op applyRule : ProofState Qid Substitution -> JudgementResult .
    op applyRule : ProofState Qid Substitution Nat Nat -> JudgementResult .
    eq applyRule(ProofState, Label, Sub) = applyRule(ProofState, Label, Sub, 0, 0) .
    ceq applyRule(ProofState, Label, Sub, N, M) =
        downTerm(ProofStateTerm, .ProofState)
      if {ProofStateTerm, Type:Type, Sub', Cont:Context} :=
          metaXapply(['AML-JUDGEMENTS], upTerm(ProofState), Label, Sub, N, unbounded, M)  .
    eq applyRule(ProofState, Label, Sub, N, M) = failure [owise] .

    op amlPatternMatch : Pattern Term           ~> Pattern .
    op amlPatternMatch : Pattern Term Condition ~> Pattern .
    op amlPatternMatch : Term    Term Condition ~> Pattern .
    eq amlPatternMatch(P, Term) = amlPatternMatch(P, Term, nil) .
    eq amlPatternMatch(P, Term, Condition) =
        amlPatternMatch(upTerm(P), Term, nil) .
    ceq amlPatternMatch(Term1, Term2, Condition) =
        downTerm(applySubstitution(Term1, Sub), bot)
      if Sub := getSubstitution(
            metaXmatch(['PRINT-AML-GOAL], Term1, Term2,
              Condition, 0, unbounded, 0)) .

    *** Print Current Goal after successful rule application
    op printSuccess : ProofState -> QidList .
    eq printSuccess(goals([0 (I:Nat): G] ; GM) ^ hilbertProof(Proof) ^ S) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G))
      if check(Proof)
        then nil
        else 'Proof 'has 'become 'invalid. '\n
             'this 'is 'a 'bug.
      fi .

    vars I N M WfI : Nat .
    vars Id PId QId RId XId FVId WfId CId1 CId2 ResId1 ResId2 : Id .
    vars NFId ACId1 ACId2 SubId SubId1 SubId2 ClaimId : Id .
    var SVar : SVar .
    var EVar : EVar .
    vars P Q R Ant Ant' Con Con' Hyp Hyp' Conclusion PreP : Pattern .
    vars Ctx Ctx1 Ctx2 : ApplicationContext .
    var Hypotheses : PatternList .
    vars AM AM1 AM2 : AntecedentMap .
    var CM : ConsequentMap .
    var G : Goal . var GM : GoalMap .
    vars Proof CommentedProof : CommentedProof .
    vars S ProofState ProofState' PrState : ProofState .
    vars PrSt PrSt1 PrSt2 PrSt3 PrSt4 PrSt5 : ProofState .
    vars PrSt6 PrSt7 PrSt8 PrSt9 PrSt10 PrSt11 : ProofState .
    var Label : Qid .
    vars ProofStateTerm Term Term1 Term2 : Term .
    vars Sub Sub' : Substitution .
    var Condition : Condition .
endm

mod AML-PROVER is
    pr AML-PROVER-COMMANDS .
    including LOOP-MODE .
    including PRETTY .
    pr AML-USER-THEORY .

    subsort ProofState < State .

    vars QIN QOUT QOUT' QOUT'' : QidList .
    vars S S' ProofState : ProofState .
    var T : ResultPair? . var Term : Term . var Type : Type .

    op init : -> System .
    eq init = [nil, .ProofState, 'AML 'THEOREM 'PROVER] .

    *** Loop mode IO rules
    crl [inputCorrectCMDSucceeds] :
        [ QIN, S, QOUT ] => [ nil, S', QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ < S' # QOUT' > := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDSucceeds] :
        [ QIN, S, QOUT ] => [ nil, S', printSuccess(S') ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ S' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDOutput] :
        [ QIN, S, QOUT ] => [ nil, S, QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ QOUT' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDMalformed] :
        [QIN, S, QOUT ] => [ nil, S,
          'Command 'is 'malformed '\n
          'Check 'that 'pattern 'arguments 'are 'well-formed ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ not (downTerm(Term, noop) :: ProverCMD) .

    crl [inputCorrectCMDFails] :
        [QIN, S, QOUT ] => [ nil, S, 'Command 'application 'failed ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ not (applyCommand(downTerm(Term, noop), S) :: CommandResult) .

    crl [inputAmbiguous] :
        [ QIN, S, QOUT ] => [ Term, S,
          'Ambiguous 'parse. 'Choosing 'first: '\n
          Term '\n ]
      if QIN =/= nil
      /\ ambiguity({Term, Type}, T) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    crl [proved] :
        [QIN, S ^ goals(mt), QOUT]
      =>
        [QIN, S',
          QOUT'' '\n
          'All 'proof 'goals 'discharged '\n
          QOUT']
      if QOUT' := applyCommand(cp, S ^ goals(mt))
      /\ < S' # QOUT'' > := applyCommand(dp, S ^ goals(mt)) .

    crl [emptyProofState] :
        [ QIN, S, QOUT ] => [nil, S,
          'ERROR: 'There 'is 'no 'proof 'in 'progress '\n
          'try 'begin 'proof 'of 'PATTERN'
          ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ noProof := applyCommand(downTerm(Term, noop), S) .

    crl [inputFail] :
        [ QIN, S, QOUT ] => [ nil, S,
          'ERROR 'on 'input: QIN '\n
          'Parsing 'failed 'at 'column pretty(N:Nat)
          ]
      if QIN =/= nil
      /\ noParse(N:Nat) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    op rewriteProofState : ProofState -> ProofState .
    eq rewriteProofState(ProofState) =
        rewriteProofState(ProofState, unbounded) .
    op rewriteProofState : ProofState Bound -> ProofState .
    ceq rewriteProofState(ProofState, B:Bound) = downTerm(Term, .ProofState)
      if {Term, Type} := metaRewrite(['AML-PROVER], upTerm(ProofState), B:Bound) .
endm
