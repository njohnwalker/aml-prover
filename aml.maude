**********************************
*** Applicative Matching Logic ***
*** Interactive Theorem Prover ***
**********************************

in checker/checker/maude/checker.maude

fmod AML-CHECKER is
    extending CHECKER * (sort Rule to AMLRule, op ___;_ to ___;;_ ) .

    *** avoid applying the equation that erases comments for ease of use
    *** mimmic the operator syntax so printed output can be read by the checker
    sort CommentedProofStep CommentedProof .
    subsort ProofStep < Proof CommentedProofStep < CommentedProof .

    op ___;_ : Id Claim AMLRule String -> CommentedProofStep [ctor] .

    op __ : CommentedProof CommentedProof -> CommentedProof [ctor ditto] .
    op __ : CommentedProof          Proof -> CommentedProof [ctor ditto] .
    op __ :          Proof CommentedProof -> CommentedProof [ctor ditto] .

    *** Explicitly convert back to the original proof constructor
    op stripComments : CommentedProof -> Proof .
    eq stripComments(Pi1 Id C Rl ; S Pi2) =
        stripComments(Pi1 Id C Rl ;; S Pi2 ) .
    eq stripComments(Pi1) = Pi1 [owise] .

    *** Helpers
    ops check check-id check-step : CommentedProof -> Bool .
    eq check(Proof) = check(stripComments(Proof)) .
    eq check-id(Proof) = check-id(stripComments(Proof)) .
    eq check-step(Proof) = check-step(stripComments(Proof)) .

    op getStepNum : CommentedProof ~> Nat .
    eq getStepNum(Pi1 (N) C Rl ;) = N .
    eq getStepNum(Pi1 (N) C Rl ; S) = N .

    *** Non-total, fails for unproved well-formed pattern Ids
    op getClaimId : CommentedProof Id ~> Id .
    eq getClaimId(Pi1 (Id' Id Rl ;  ) Pi2, Id) = Id' .
    eq getClaimId(Pi1 (Id' Id Rl ; S) Pi2, Id) = Id' .

    op getStepId : CommentedProof Claim AMLRule ~> Id .
    eq getStepId(Pi1 Id C Rl ; Pi2, C, Rl) = Id .
    eq getStepId(Pi1 Id C Rl ; S Pi2, C, Rl) = Id .

    vars N M : Nat .
    vars Id Id' : Id .
    var C : Claim . var Rl : AMLRule . var S : String .
    vars Pi1 Pi2 Proof : CommentedProof .
    var PrStep : ProofStep .
endfm

******************************
*** AML Syntax Definitions ***
******************************
fmod VARIABLES is
    protecting AML-CHECKER .
    protecting QID .
    sorts EVar SVar Var .
    subsort EVar SVar < Var .
    op evar : Qid -> EVar [ctor] .
    op svar : Qid -> SVar [ctor] .

    op getVarName : Var -> Qid .
    eq getVarName(evar(Q)) = Q .
    eq getVarName(svar(Q)) = Q .

    op getVarType : Var -> Claim .
    eq getVarType(EV) = (\evar) .
    eq getVarType(SV) = (\svar) .

    var Q : Qid . var EV : EVar . var SV : SVar .
endfm

fmod AML-CORE is protecting VARIABLES .
    protecting EXT-BOOL .
*** terse AML Patterns

    sorts Symbol Pattern .
    subsort Var Symbol < Pattern .

    *** Pattern Application
    op _@_ : Pattern Pattern -> Pattern [ctor gather (E e) format (d s ++s --)] .

    *** Patten Implication
    op _-->_ : Pattern Pattern -> Pattern [ctor gather (e E) format (d s s++ --)] .

    *** Bottom
    op bot : -> Pattern [ctor] .

    *** Universal quantification
    op exists_._ : EVar Pattern -> Pattern [ctor format (d s s s++ --)] .

    *** least fixpoint
    op mu_._ : SVar Pattern ~> Pattern [ctor format (d s s s++ --)] .
    *** condition on set variable fixpoints
    cmb mu X . P : Pattern if positive(X,P) .

    op positive : SVar Pattern -> Bool .
    eq positive(X,P) = $positive(true, X, P) .

    op $positive : Bool SVar Pattern -> Bool .
    eq $positive(B, X, bot) = true .
    eq $positive(B, X, S) = true .
    eq $positive(B, X, X) = B .
    eq $positive(B, X, X') = true .
    eq $positive(B, X, P @ Q) = $positive(B, X, P) and-then $positive(B, X, Q) .
    eq $positive(B, X, P --> Q) = $positive(not B, X, P) and-then $positive(B, X, Q) .
    eq $positive(B, X, exists (x:EVar) . P) = $positive(B, X, P) .
    eq $positive(B, X, mu X . P) = true .
    eq $positive(B, X, mu X' . P) = $positive(B, X, P) .

    var B : Bool .
    vars X X' : SVar .
    var S : Symbol .
    vars P Q : Pattern .
endfm

view Pattern from TRIV to AML-CORE is sort Elt to Pattern . endv
view Symbol  from TRIV to AML-CORE is sort Elt to Symbol  . endv
view Var     from TRIV to AML-CORE is sort Elt to Var     . endv

fmod PATTERN-SET is
    inc SET{Pattern} *
        ( sort NeSet{Pattern} to NePatternSet
        , sort Set{Pattern} to PatternSet
        ) .
endfm

fmod PATTERN-LIST is
    inc LIST{Pattern} *
        ( sort NeList{Pattern} to NePatternList
        , sort List{Pattern} to PatternList
        ) .
endfm

fmod AML is including AML-CORE .
    protecting PATTERN-SET .
*** Add syntactic sugar and variable substitution
*** to AML core representation

    vars P Q P' P'' : Pattern .
    var x : EVar .
    vars X X' : SVar .
    var S : Symbol .
    vars V V' : Var .

    *** Top
    op top : -> Pattern .
    eq top = exists evar('x) . evar('x) .

    *** Not
    op ~_ : Pattern -> Pattern .
    eq ~ P = P --> bot .

    *** Or, And
    ops _\/_ _/\_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P \/ Q = (~ P) --> Q .
    eq P /\ Q = ~((~ P) \/ (~ Q)) .


    *** If-and-only-if
    op _<-->_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P <--> Q = (P --> Q) /\ (Q --> P) .

    *** Quantifiers
    op forall_._ : EVar Pattern -> Pattern .
    eq forall x . P = ~ (exists x . ~ P ) .

    *** greatest fixpoint
    op nu_._ : EVar Pattern ~> Pattern .
    eq nu X . P = ~ (mu X . ~ (P[~ X / X])) .

    ********************
    *** Substitution ***
    op _[_/_] : Pattern Pattern Var ~> Pattern [prec 39].

    *** Alpha capture substitution side-condition
    op alphaCapture : -> [Pattern] .
    ceq P [Psub / V] = alphaCapture if alphaCaptures(V, P, Psub) .

    eq bot[Psub / V] = bot .
    eq S[Psub / V] = S .
    eq V[Psub / V] = Psub .
    eq V'[Psub / V] = V' .

    eq (P @ P')[Psub / V] = (P[Psub / V]) @ (P'[Psub / V]) .

    eq (P --> P')[Psub / V] = P[Psub / V] --> (P'[Psub / V]) .

    eq (exists V . P)[Psub / V] = exists V . P .
    eq (exists V' . P)[Psub / V] = exists V' . (P[Psub  / V]) .

    eq (mu V . P)[Psub / V] = mu V . P .
    eq (mu V' . P)[Psub / V] = mu V' . (P[Psub  / V]) .

    op isFreeIn : Var Pattern -> Bool .
    eq isFreeIn(V, bot) = false .
    eq isFreeIn(V, V) = true .
    eq isFreeIn(V, V') = false .
    eq isFreeIn(V, S) = false .
    eq isFreeIn(V, P @ P') = isFreeIn(V, P) or-else isFreeIn(V, P') .
    eq isFreeIn(V, P --> P') = isFreeIn(V, P) or-else isFreeIn(V, P') .
    eq isFreeIn(V, exists V . P) = false .
    eq isFreeIn(V, exists V' . P) = isFreeIn(V, P) .
    eq isFreeIn(V, mu V . P) = false .
    eq isFreeIn(V, mu V' . P) = isFreeIn(V, P) .

    var B : Bool .
    var Psub : Pattern .
    var Vb : Var .
    op alphaCaptures : Var Pattern Pattern -> Bool .
    eq alphaCaptures(V, P, Psub) = $alphaCaptures(false, V, P, Psub) .

    op $alphaCaptures : Bool Var Pattern Pattern -> Bool .
    eq $alphaCaptures(B, Vb, Vb, Psub) = B .

    eq $alphaCaptures(B, Vb, bot, Psub) = false .

    eq $alphaCaptures(B, Vb, V', Psub) = false .

    eq $alphaCaptures(B, Vb, S, Psub) = false .

    eq $alphaCaptures(B, Vb, P @ P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, P --> P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, exists Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, exists V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .

    eq $alphaCaptures(B, Vb, mu Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, mu V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .

    var PS : PatternSet .
    op getSymbols : PatternSet -> PatternSet .
    eq getSymbols(S) = S .
    eq getSymbols(bot) = empty .
    eq getSymbols(V) = empty .
    eq getSymbols(P @ P') = getSymbols(P) , getSymbols(P') .
    eq getSymbols(P --> P') = getSymbols(P) , getSymbols(P') .
    eq getSymbols(exists V . P) = getSymbols(P) .
    eq getSymbols(mu V . P) = getSymbols(P) .
    eq getSymbols((P, PS)) = getSymbols(P) , getSymbols(PS) .

    op getVars : PatternSet -> PatternSet .
    eq getVars(V) = V .
    eq getVars(bot) = empty .
    eq getVars(S) = empty .
    eq getVars(P @ P') = getVars(P) , getVars(P') .
    eq getVars(P --> P') = getVars(P) , getVars(P') .
    eq getVars(exists V . P) = V, getVars(P) .
    eq getVars(mu V . P) = V, getVars(P) .
    eq getVars((P, PS)) = getVars(P) , getVars(PS) .
endfm

***********************
*** PRETTY PRINTING ***
***********************
fmod META-LEVEL' is pr META-LEVEL * ( op _`,_ to _~_ ) .
endfm

fmod PRETTY is pr AML .
    pr META-LEVEL' .

    *** Natural Numbers
    vars N : Nat .
    op pretty : Nat -> QidList .
    eq pretty(N:Nat) = metaPrettyPrint(['NAT], upTerm(N:Nat)) .

    op prettyString : Nat -> String .
    eq prettyString(N) = string(pretty(N)) .

    *** Patterns
    var P : Pattern .
    op pretty : Pattern -> QidList .
    eq pretty(P) = metaPrettyPrint(['AML-USER-THEORY], upTerm(P)) .

endfm

in aml-user-theory.maude

**********************
*** Prover Modules ***
**********************
mod AML-GOAL is including AML .
    pr PRETTY .
    pr PATTERN-LIST .
    sorts ConsequentMap AntecedentMap .

    op mt : -> AntecedentMap [ctor] .
    op mt : -> ConsequentMap [ctor] .
    op [-_`(_`):_] : Nat Nat Pattern -> AntecedentMap [ctor format (d s d s d d d n++i -- d) ] .
    op  [_`(_`):_] : Nat Nat Pattern -> ConsequentMap [ctor format (d sss s d d d n++i -- d) ] .
    op _;_ : AntecedentMap AntecedentMap -> AntecedentMap [ctor assoc id: mt format (d s n d) ] .
    op _;_ : ConsequentMap ConsequentMap -> ConsequentMap [ctor assoc id: mt format (d s n d) ] .

    sort Goal .
    op _|-_ : AntecedentMap ConsequentMap -> Goal [ctor prec 100 format (d nt n d)] .
    op proved : Pattern Id Id -> Goal [ctor] .

    sort GoalMap .
    op mt : -> GoalMap [ctor] .
    op [_`(_`):_] : Nat Nat Goal -> GoalMap [ctor] .
    op _;_ : GoalMap GoalMap -> GoalMap [ctor assoc id: mt] .

*** Antecedent Map Invariant
*** requires: exists a (-1) indexed element in the map
    crl [antecedentMapInvariant] :
        [- N (I): P] ; [- M (I'): P'] => [- s M (I): P] ; [- M (I'): P']
      if N == M or N > s M .

*** Consequent and Goal Map invariants
*** requires: exists a 0 indexed element in the map
    crl [consequentMapInvariant] :
        [N (I): P] ; [M (I'): P'] => [N (I): P] ; [s N (I'): P']
      if M == N or M > s N .

    crl [goalMapInvariant] :
        [N (I): G] ; [M (I'): G'] => [N (I): G] ; [s N (I'): G']
      if M == N or M > s N .

    *** Construct a AntecedentMap from a set of Patterns
    op makeClaim : PatternList Pattern -> Pattern .
    eq makeClaim(nil, Conclusion) = Conclusion .
    eq makeClaim(P PL, Conclusion) = P --> makeClaim(PL, Conclusion) .

    *** Print a GoalMap
    op pretty : GoalMap -> QidList .
    eq pretty([N (I): AM |- [0 (I): P]; CM] ; GM) =
        pretty(N) ': '... '|- pretty(P) '\n
        pretty(GM) .
    eq pretty(mt) = nil .

    op fresh : AntecedentMap -> Nat .
    eq fresh((mt).AntecedentMap) = 1 .
    eq fresh([- N (I): P] ; AM) = s N .

    op fresh : ConsequentMap -> Nat .
    eq fresh((mt).ConsequentMap) = 0 .
    eq fresh(CM ; [N (I): P]) = N .

    var AM : AntecedentMap . var CM : ConsequentMap . var GM : GoalMap .
    vars N M I I' : Nat .
    vars P P' Conclusion : Pattern .
    var PL : PatternList .
    vars G G' : Goal .
endm

*** Module to metaPrettyPrint all user space AML symbols and Proof goals
*** useful for more efficient meta-representation of module to print in
mod PRINT-AML-GOAL is protecting AML-GOAL + AML-USER-THEORY . endm

mod AML-PROOF-STATE is
    pr AML-GOAL . inc AML-CHECKER .
    pr PRINT-AML-GOAL .

    pr PATTERN-SET .
    pr MAP{Symbol, Nat} * ( op undefined to undefinedSym, op _|->_ to _|-S>_ ) .
    pr MAP{Var, Nat} * ( op undefined to undefinedVar, op _|->_ to _|-V>_ ) .

    sort ProofState .
    op .ProofState : -> ProofState [ctor] .
    op _^_ : ProofState ProofState -> ProofState [assoc comm ctor format (d ni s d)] .

    ops goalCounter : Nat -> ProofState [ctor] .
    op goals : GoalMap -> ProofState [ctor format (++ --)] .

    op symbolIndex : Map{Symbol,Nat} -> ProofState [ctor] .

    op variableIndex : Map{Var,Nat} -> ProofState [ctor] .

    *** intermediate proof objects
    op hilbertProof : CommentedProof -> ProofState [ctor] .
    op tacticProof : -> ProofState [ctor] . *** TODO

    *** Projections
    op getProof : ProofState -> CommentedProof .
    eq getProof(hilbertProof(Proof) ^ ProofState) = Proof .
    eq getProof(ProofState) = .Proof [owise] .

    var Proof : CommentedProof .
    var ProofState : ProofState .
endm

*** Useful sub-proofs for AML proofs
mod AML-PROOF-LEMMAS is
    pr AML-PROOF-STATE .

    sort ProofAndIndex .
    op {_,_} : CommentedProof Id -> ProofAndIndex .

    *** Modus Ponens proof step helper function
    vars AntWfId HypWfId ConsequentWfId AntClaimId HypClaimId : Id .
    op modusPonensLemma : Id Id CommentedProof -> ProofAndIndex .
    ceq modusPonensLemma(AntWfId, HypWfId, Proof) =
        { Proof (s getStepNum(Proof)) ConsequentWfId (MP AntClaimId HypClaimId) ; ,
          ConsequentWfId }
      if AntClaimId := getClaimId(Proof, AntWfId)
      /\ HypClaimId := getClaimId(Proof, HypWfId)
      /\ Pi1 HypWfId (\imp AntWfId ConsequentWfId) (WF) ; Pi2 := stripComments(Proof) .

    *** Identity Implication Tautology (P -> P)
    op propILemma : Nat Id -> ProofAndIndex .
    eq propILemma(N, PatWFId) =
        { (     N) (\imp PatWFId PatWFId)  (WF) ; "begin propILemma"
                                                  ***| P -> P
          (1  + N) (\imp PatWFId (N))      (WF) ; ***| P -> (P -> P)
          (2  + N) (1 + N)              (PropK) ; ***| PropK P P
          (3  + N) (\imp (N) PatWFId)      (WF) ; ***| (P -> P) -> P
          (4  + N) (\imp PatWFId (3 + N))  (WF) ; ***| P -> ((P -> P) -> P)
          (5  + N) (4 + N)              (PropK) ; ***| PropK P (P -> P)
          (6  + N) (\imp (1 + N) (N))      (WF) ; ***| (P -> (P -> P)) -> (P -> P)
          (7  + N) (\imp (4 + N) (6 + N))  (WF) ; ***| (P -> ((P -> P) -> P))
                                                  ***  -> ((P -> (P -> P)) -> (P -> P))
          (8  + N) (7 + N)              (PropS) ; ***| PropS P (P -> P) P
          (9  + N) (6 + N) (MP (5 + N) (8 + N)) ; ***| MP 5 8
          (10 + N) (    N) (MP (2 + N) (9 + N)) ; ***| MP 2 9
                                                  "end propILemma"
          , (N) }
        .

    op propBLemma : Nat Id Id Id -> ProofAndIndex .
    op propCLemma : Nat Id Id Id -> ProofAndIndex .
    op PropWLemma : Nat Id Id    -> ProofAndIndex .

    sort ProofStateAndIndex .
    op {_,_} : ProofState Id -> ProofStateAndIndex .

    op  wfPatternLemma : Pattern ProofState -> ProofStateAndIndex .
    eq  wfPatternLemma(P, PrSt ^
          goals(GM ; [N (I): AM ; [- M (WfI): P ] ; AM' |- CM]  ; GM')) =
        {PrSt ^ goals(GM ; [N (I): AM ; [- M (WfI): P ] ; AM' |- CM]  ; GM'),
          (WfI)} .

    eq  wfPatternLemma(bot, PrSt) = {PrSt, (0)} .

    ceq wfPatternLemma(V, variableIndex(VM) ^ PrSt) =
        {variableIndex(VM) ^ PrSt, (M)}
      if M := VM[V] .

    ceq wfPatternLemma(V, variableIndex(VM) ^ hilbertProof(Proof) ^ PrSt) =
        { variableIndex((VM, V |-V> N)) ^
            hilbertProof(Proof (N) getVarType(V) (WF) ; string(getVarName(V))) ^
            PrSt
            , (N) }
      if undefinedVar := VM[V] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ PrSt)  =
        {symbolIndex(SM) ^ PrSt, (M)}
      if M := SM[S] .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ hilbertProof(Proof) ^ PrSt) =
        { symbolIndex((SM, S |-S> N)) ^
            hilbertProof(Proof (N) (\symb) (WF) ; string(pretty(S))) ^
            PrSt
            , (N) }
      if undefinedSym := SM[S] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(exists EV . P, PrSt) =
        appendProofStep(PrSt'', (\ex Id1 Id2), (WF))
      if {PrSt', Id1} := wfPatternLemma(EV, PrSt)
      /\ {PrSt'', Id2} := wfPatternLemma(P, PrSt') .

    ceq wfPatternLemma(mu SV . P, PrSt) =
        appendProofStep(PrSt''', (\mu Id1 Id3), (WFMu Id2))
      if {PrSt', Id1} := wfPatternLemma(SV, PrSt)
      /\ {PrSt'', Id2} := nonNegativeLemma(SV, P, PrSt')
      /\ {PrSt''', Id3} := wfPatternLemma(P, PrSt'') .

    ceq wfPatternLemma(P @ P', PrSt) =
        appendProofStep(PrSt'', (\app Id1 Id2), (WF))
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt'', Id2} := wfPatternLemma(P', PrSt') .

    ceq wfPatternLemma(P --> P', PrSt) =
        appendProofStep(PrSt'', (\imp Id1 Id2), (WF) )
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt'', Id2} := wfPatternLemma(P', PrSt') .

    op appendProofStep : ProofState Claim AMLRule -> ProofStateAndIndex .
    ceq appendProofStep(PrSt, Claim, Rule) = { PrSt, Id }
      if Id := getStepId(getProof(PrSt), Claim, Rule) .

    ceq appendProofStep(PrSt ^ hilbertProof(Proof), Claim, Rule) =
        { PrSt ^ hilbertProof(Proof (N) Claim Rule ;), (N) }
      if N := s getStepNum(Proof) [owise] .

    op nonNegativeLemma : SVar Pattern ProofState -> ProofStateAndIndex .

    vars N N' N'' N''' M M' I WfI : Nat .
    vars Id Id1 Id2 Id3 PatWFId : Id .
    var S : Symbol . vars P P' : Pattern .
    var V : Var . var EV : EVar . var SV : SVar .
    var Claim : Claim . var Rule : AMLRule .
    vars Proof Proof' Proof'' Pi1 Pi2 : CommentedProof .
    vars SM SM' : Map{Symbol,Nat} . vars VM VM' : Map{Var,Nat} .
    vars GM GM' : GoalMap . vars AM AM' : AntecedentMap . var CM : ConsequentMap .
    vars PrSt PrSt' PrSt'' PrSt''' : ProofState .
endm

mod AML-PROOF-STATE-TRANSITIONS is
    inc AML-PROOF-STATE .
    inc AML-PROOF-LEMMAS .

    op initializeProofState : PatternList Pattern -> ProofState .
    eq initializeProofState(Assumptions, Conclusion) =
        tacticProof
        ^ hilbertProof((0) (\bot) (WF) ;)
        ^ goalCounter(1)
        ^ symbolIndex(empty)
        ^ variableIndex(empty)
        ^ goals(
          [ 0 (0):
            mt |- [ 0 (0): makeClaim(Assumptions,Conclusion) ]
            ]
          )
        .

    *** GoalMap precondition
    crl [gmPre] : goals([N (I): G] ; GM ) => goals([0 (I): G] ; GM) if N > 0 .

    vars N I : Nat .
    var Conclusion : Pattern . var Assumptions : PatternList .
    var G : Goal . var GM : GoalMap .
endm

mod AML-JUDGEMENTS is including AML-PROOF-STATE-TRANSITIONS .
***(
The rewrite rules in this module define the proof rules,
judgments, and tactics for interactive AML Proofs
Every rule should be labelled and marked `nonexec`
since they will be `metaApply`ed by the applyCommand
equation to enable pattern matching and substitution
preprocessing as well as descriptive error messages .
)
***********************
*** AML Proof Rules ***
***********************

*** Propositional K combinator Tautology P --> (Q --> P)
*** RHS Free Variables:
*** - `P` instantiating Pattern
*** - `Q` instantiating Pattern
    crl [propK] :
        ProofState
      =>
        ProofState' ^
        hilbertProof(Proof' (s N) (KWfI) (PropK) ;) ^
        goals(
          GM ;
          [ GIndex (GI):
            [- fresh(AM) (KWfI): P --> (Q --> P)] ; AM |- CM ] ;
          GM'
        )

      if hilbertProof(Proof) ^
         variableIndex(VM) ^ symbolIndex(SM) ^
         goals(GM ; [GIndex (GI): AM |- CM ] ; GM') ^
         PrState := ProofState
      /\ { PrState', (KWfI) } := wfPatternLemma(P --> (Q --> P), ProofState)
      /\  ProofState' ^
          hilbertProof(Proof') ^
          goals(GM ; [GIndex (GI): AM |- CM ] ; GM') := PrState'
      /\ N := getStepNum(Proof')
      [nonexec] .

*** Propositional S combinator Tautology
***     P --> (Q --> R) --> (P --> Q) -> (P --> R)
*** RHS Free Variables:
*** - `P` instantiating Pattern
*** - `Q` instantiating Pattern
*** - `R` instantiating Pattern
    crl [propS] :
        ProofState
      =>
        ProofState' ^
        hilbertProof(Proof' (s N) (SWfI) (PropS) ;) ^
        goals(
          GM ;
          [ GIndex (GI):
            [- fresh(AM) (SWfI):
              (P --> Q --> R) -->
              (P --> Q) -->
              (P --> R) ] ; AM |- CM ] ;
          GM'
        )

      if hilbertProof(Proof) ^
         variableIndex(VM) ^ symbolIndex(SM) ^
         goals(GM ; [GIndex (GI): AM |- CM ] ; GM') ^
         PrState := ProofState
      /\ { PrState', (SWfI) } := wfPatternLemma(
              (P --> Q --> R) --> (P --> Q) -->  (P --> R), ProofState)
      /\  ProofState' ^
          hilbertProof(Proof') ^
          goals(GM ; [GIndex (GI): AM |- CM ] ; GM') := PrState'
      /\ N := getStepNum(Proof')
      [nonexec] .

*** Modus Ponens Inference Rule
    crl [modusPonens] :
        hilbertProof(Proof) ^
        goals(GM ;
          [ GIndex (GI):
            AM1 ; [- L (WfIHyp): Antecedent --> Consequent ] ;
            AM2 ; [- M (WfIAnt): Antecedent ] ;
            AM3
            |- CM ] ;
          GM')
      =>
        hilbertProof(Proof') ^
        goals(GM ;
          [ GIndex (GI):
                  [- fresh(AM1) (WfICon):       Consequent ] ;
            AM1 ; [- L (WfIHyp): Antecedent --> Consequent ] ;
            AM2 ; [- M (WfIAnt): Antecedent ] ;
            AM3
            |- CM ] ;
          GM')
      if {Proof', (WfICon)} := modusPonensLemma((WfIAnt), (WfIHyp), Proof)
      [nonexec] .

    *** Existence
    crl [existence] :
        ProofState
      =>
        PrState ^
        goals(
          GM ;
          [ GIndex (GI):
              [- fresh(AM) (WfI): exists EVar . EVar] ; AM |- CM ] ;
          GM'
        )
      if {ProofState', (WfI)} := wfPatternLemma(exists EVar . EVar , ProofState)
      /\ {ProofState'', ClaimId} := appendProofStep(ProofState', (WfI), (Existence))
      /\ PrState ^ goals(GM ; [GIndex (GI): AM |- CM] ; GM') := ProofState''
      [nonexec] .
***************************
*** Derived Proof Rules ***
***************************
*** Identity Tautology P --> P
*** RHS Free Variables:
*** - `IdPattern` instantiating Pattern
    crl [identity] :
        ProofState
      =>
        ProofState' ^
        hilbertProof(Proof' Proof'') ^
        goals(GM ; [GIndex (N): [- fresh(AM) (I): IdPattern --> IdPattern] ; AM |- CM ] ; GM')
      if hilbertProof(Proof) ^
         variableIndex(VM) ^ symbolIndex(SM) ^
         goals(GM ; [GIndex (N): AM |- CM ] ; GM') ^
         PrState := ProofState
      /\ { ProofState' ^
           goals(GM ; [GIndex (N): AM |- CM ] ; GM') ^
           hilbertProof(Proof'),
           WfId
         } := wfPatternLemma(IdPattern, ProofState)
      /\ {Proof'', (I)} := propILemma(s getStepNum(Proof'), WfId) [nonexec] .

******************************
*** Sequent Calculus Rules ***
******************************
    rl [axiom] :
        hilbertProof(Proof) ^
        goals(GM ; [GIndex (I): AM1 ; [- N (WfI): P] ; AM2 |- CM1 ; [M (I2): P] ; CM2] ; GM')
      =>
        hilbertProof(Proof) ^
        goals(GM ; [GIndex (I): proved(P, (WfI), getClaimId(Proof, (WfI)))] ; GM')
        [nonexec] .

    vars K L M N I I1 I2 GI WfI KWfI SWfI WfIAnt WfIHyp WfICon GIndex : Nat .
    vars Id Id' WfId WfId' PWfId QWfId RWfId ClaimId : Id .
    vars Proof Proof' Proof'' Pi1 Pi2 PrSt : CommentedProof .
    var V : Var . var EVar : EVar .
    vars P Q R Antecedent Hypothesis Consequent Conclusion IdPattern : Pattern .
    vars PS Assumptions : PatternSet .
    vars S : Symbol .
    vars SM SM' : Map{Symbol,Nat} . vars VM VM' : Map{Var,Nat} .
    vars GM GM' : GoalMap . vars AM AM' AM'' AM1 AM2 AM3 : AntecedentMap .
    vars CM CM1 CM2 : ConsequentMap .
    vars ProofState ProofState' ProofState'' PrState PrState' PrState'' PrState'''
        : ProofState .
endm

fmod SUBSTITUTION is pr META-LEVEL' .
***  Take a Substitution, Like one from a metaXmatch result,
*** and instantiate the matched term.
*** This helps with AML-Pattern Pattern matching in prover commands
    op applySubstitution : Term     Substitution -> Term .
    op applySubstitution : TermList Substitution -> TermList .

    eq applySubstitution(Con, Sub) = Con .

    eq applySubstitution(Var, Var <- T ; Sub) = T .
    eq applySubstitution(Var, Sub) = Var [owise] .

    eq applySubstitution(Operator[Args], Sub) =
        Operator[applySubstitution(Args, Sub)] .

    eq applySubstitution(empty, Sub) = empty .
    eq applySubstitution((T ~ Ts), Sub) =
        applySubstitution(T, Sub) ~ applySubstitution(Ts, Sub) .

    var Var : Variable .
    var Con : Constant .
    var T : Term . var Ts : NeTermList .
    var Operator : Qid .
    vars Args : TermList .
    var Sub : Substitution .
endfm

mod AML-PROVER-COMMANDS is including AML-PROOF-STATE-TRANSITIONS .
    inc AML-JUDGEMENTS .
    protecting INT .
    protecting PRINT-AML-GOAL .
    protecting AML-GOAL .
    protecting AML-USER-THEORY .

    protecting LOOP-MODE .
    protecting SUBSTITUTION .
    protecting PRETTY .
    sorts Tactic MLRule ProverCMD .

*************************
*** Basic UI Commands ***
*************************
    op noop : -> ProverCMD [ctor] .

    sort EmptyProofCMD . subsort EmptyProofCMD < ProverCMD .
    op begin`proof`of_assuming_ : Pattern PatternList -> EmptyProofCMD [ctor gather (& E)] .
    op begin`proof`of_ : Pattern -> ProverCMD [prec 42] .
    eq begin proof of P = begin proof of P assuming nil .

    op sg_ : Nat -> ProverCMD [ctor] .
    op switch`goal_ : Nat -> ProverCMD .
    eq switch goal N:Nat = sg N:Nat .

    op pp : -> ProverCMD [ctor] .
    op print`proof : -> ProverCMD .
    eq print proof = pp .

    op pg : -> ProverCMD [ctor] .
    op print`goal : -> ProverCMD .
    eq print goal = pg .

    op pgs : -> ProverCMD [ctor] .
    op print`goals : -> ProverCMD .
    eq print goals = pgs .

    op cp : -> ProverCMD [ctor] .
    op check`proof : -> ProverCMD .
    eq check proof = cp .

    op dp : -> ProverCMD [ctor] .
    op dump`proof : -> ProverCMD .
    eq dump`proof = dp .

*******************************
*** AML Proof Rule Commands ***
*******************************
    sort PatternProverCMD .
    subsort PatternProverCMD < ProverCMD .
    *** Prop Κ:
    ***  Γ |- Δ
    *** ---------------------
    ***  Γ, P -> Q -> P |- Δ
    op K__ : Pattern Pattern -> PatternProverCMD [ctor prec 42] .
    op propK__ : Pattern Pattern -> PatternProverCMD [prec 42].
    eq propK P Q = K P Q .

    *** Prop S:
    ***  Γ |- Δ
    *** -------------------------------------------------
    ***  Γ, (P -> (Q -> R)) -> (P -> Q) -> (P -> R) |- Δ
    op S___ : Pattern Pattern Pattern -> ProverCMD [ctor prec 42] .
    op propS___ : Pattern Pattern Pattern -> ProverCMD [prec 42].
    eq propS P Q R = S P Q R .

    *** Prop F:
    ***  Γ |- Δ
    *** ----------------------------------
    ***  Γ, ((P -> _|_) -> _|_) -> P |- Δ
    op F_ : Pattern -> ProverCMD [ctor prec 42] .
    op propF_ : Pattern -> ProverCMD .
    eq propS P Q R = S P Q R .

    *** Modus Ponens:
    ***  Γ, P, P -> Q |- Δ
    *** ----------------------
    ***  Γ, P, P -> Q, Q |- Δ
    op mp__ : Pattern Pattern -> ProverCMD [ctor] .
    op modus`ponens__ : Pattern Pattern -> ProverCMD [ctor] .
    eq modus ponens P Q  = mp P Q .

    *** Existence
    ***  Γ |- Δ
    *** ------------------
    ***  Γ, ∃ x . x, |- Δ
    op ex_ : Qid -> ProverCMD [ctor] .
    op existence_ : Qid -> ProverCMD .
    eq existence Q:Qid = ex Q:Qid .

***************************
*** Derived Proof Rules ***
***************************
    *** Identity Tautology:
    ***  Γ |- Δ
    *** --------
    ***  Γ, P -> P |- Δ
    op id_ : Pattern -> ProverCMD [ctor prec 42] .
    op identity_ : Pattern -> ProverCMD [prec 42] .
    eq identity P = id P .

******************************
*** Sequent Calculus Rules ***
******************************
    *** Axiom:
    *** ----------
    ***  Γ, ax |- ax, Δ
    op ax : -> ProverCMD [ctor] .
    op axiom : -> ProverCMD .
    eq axiom = ax .

**********************************
*** Prover Command Application ***
    sort CommandResult .
    subsort ProofState QidList < CommandResult .
    op <_#_> : ProofState QidList -> CommandResult [ctor] .
    op noProof : -> CommandResult [ctor] .
    op applyCommand : ProverCMD ProofState -> CommandResult .

*************************
*** Basic UI Commands ***
*************************
    *** Initiate prover loop
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, .ProofState) =
        initializeProofState(Hypotheses, Conclusion) .

    *** Do not overwrite proof with `begin proof`
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, ProofState) =
        ''begin 'proof' 'will 'overwrite 'current 'proof '\n
        'please ''dump 'proof' 'and 'try 'again '\n .

    *** Empty ProofState
    ceq applyCommand(CMD:ProverCMD, .ProofState) = noProof
      if not (CMD:ProverCMD :: EmptyProofCMD) .

    *** Print Goals
    eq applyCommand(pgs, goals(GM) ^ ProofState) = pretty(GM) .

    *** Check Proof
    eq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
      if check-id(Proof) then
        if check-step(Proof)
          then 'Proof 'is 'valid
          else 'Invalid 'Proof 'Step
          fi
        else 'Invalid 'Proof 'Index
        fi .

    *** Print Proof
    eq applyCommand(pp, hilbertProof(CommentedProof) ^ ProofState) =
        metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) .

    *** Print proof and start over
    eq applyCommand(dp, hilbertProof(CommentedProof) ^ ProofState) =
        < .ProofState # metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) > .

    eq applyCommand(pg, goals([0 (I): G] ; GM) ^ ProofState) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G))  .

***********************
*** AML Proof Rules ***
***********************
    *** PropK
    eq applyCommand(K P Q, ProofState) =
        applyRule(ProofState, 'propK,
          'GIndex:Nat <- upTerm(0) ;
          'P:Pattern <- upTerm(P) ;
          'Q:Pattern <- upTerm(Q)) .

    *** PropS
    eq applyCommand(S P Q R, ProofState) =
        applyRule(ProofState, 'propS,
          'GIndex:Nat <- upTerm(0) ;
          'P:Pattern <- upTerm(P) ;
          'Q:Pattern <- upTerm(Q) ;
          'R:Pattern <- upTerm(R)) .

    *** PropF
    eq applyCommand(F P, ProofState) =
        applyRule(ProofState, 'propF,
          'GIndex:Nat <- upTerm(0) ;
          'P:Pattern <- upTerm(P) ) .

    *** Modus Ponens
    ceq applyCommand(mp Ant Con, ProofState) = ProofState'
      if PrState ^ goals([ 0 (I): AM |- CM  ] ; GM) := ProofState
      /\ Ant' --> Con' := amlPatternMatch(Ant --> Con, upTerm(AM))
      /\ Ant' := amlPatternMatch(Ant', upTerm(AM))
      /\ ProofState' := applyRule(ProofState, 'modusPonens,
            'GIndex:Nat <- upTerm(0) ;
            'Antecedent:Pattern <- upTerm(Ant') ;
            'Consequent:Pattern <- upTerm(Con') ) .

    eq applyCommand(mp Ant Con, ProofState) =
        'Modus 'Ponens 'failed .

    eq applyCommand(ex Q:Qid, ProofState) =
        applyRule(ProofState, 'existence, 'EVar:EVar <- upTerm(evar(Q:Qid))) .

***************************
*** Derived Proof Rules ***
***************************
    *** IDENTITY assumption
    eq applyCommand(id P, ProofState) =
        applyRule(ProofState, 'identity,
          'GIndex:Nat <- upTerm(0) ;
          'IdPattern:Pattern <- upTerm(P)) .

******************************
*** Sequent Calculus Rules ***
******************************
    *** AXIOM
    ceq applyCommand(ax, ProofState) = ProofState'
      if ProofState' :=
          applyRule(ProofState, 'axiom, 'GIndex:Nat <- upTerm(0)) .

    eq applyCommand(ax, ProofState) =
        'No 'match 'for 'AXIOM 'judgement [owise] .

*** Helper Functions
    *** Apply a rule contained in the AML-JUDGEMENTS module
    sort JudgementResult .
    subsort ProofState < JudgementResult .
    op failure : -> JudgementResult [ctor] .
    op applyRule : ProofState Qid Substitution -> JudgementResult .
    op applyRule : ProofState Qid Substitution Nat Nat -> JudgementResult .
    eq applyRule(ProofState, Label, Sub) = applyRule(ProofState, Label, Sub, 0, 0) .
    ceq applyRule(ProofState, Label, Sub, N, M) =
        downTerm(ProofStateTerm, .ProofState)
      if {ProofStateTerm, Type:Type, Sub', Cont:Context} :=
          metaXapply(['AML-JUDGEMENTS], upTerm(ProofState), Label, Sub, N, unbounded, M)  .
    eq applyRule(ProofState, Label, Sub, N, M) = failure [owise] .

    op amlPatternMatch : Pattern Term -> Pattern .
    eq amlPatternMatch(P, Term) =
        downTerm(
          applySubstitution(
            upTerm(P),
            getSubstitution(
              metaXmatch(
                ['PRINT-AML-GOAL],
                upTerm(P),
                Term,
                nil,
                0, unbounded, 0))),
          bot) .

    *** Print Current Goal after successful rule application
    op printSuccess : ProofState -> QidList .
    eq printSuccess(goals([0 (I:Nat): G] ; GM) ^ S) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G)) .

    vars I N M : Nat .
    vars P Q R Ant Ant' Con Con' Conclusion : Pattern .
    var Hypotheses : PatternList .
    var AM : AntecedentMap .
    var CM : ConsequentMap .
    var G : Goal . var GM : GoalMap .
    vars Proof CommentedProof : CommentedProof .
    vars S ProofState ProofState' PrState : ProofState .
    var Label : Qid . vars ProofStateTerm Term : Term . vars Sub Sub' : Substitution .
endm

mod AML-PROVER is
    pr AML-PROVER-COMMANDS .
    including LOOP-MODE .
    including PRETTY .
    pr AML-USER-THEORY .

    subsort ProofState < State .

    vars QIN QOUT QOUT' QOUT'' : QidList .
    vars S S' ProofState : ProofState .
    var T : ResultPair? . var Term : Term . var Type : Type .

    op init : -> System .
    eq init = [nil, .ProofState, nil] .

    *** Loop mode IO rules
    crl [inputCorrectCMDSucceeds] :
        [ QIN, S, QOUT ] => [ nil, S', QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ < S' # QOUT' > := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDSucceeds] :
        [ QIN, S, QOUT ] => [ nil, S', printSuccess(S') ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ S' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDOutput] :
        [ QIN, S, QOUT ] => [ nil, S, QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ QOUT' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDMalformed] :
        [QIN, S, QOUT ] => [ nil, S,
          'Command 'is 'malformed '\n
          'Check 'that 'pattern 'arguments 'are 'well-formed ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ not (downTerm(Term, noop) :: ProverCMD) .

    crl [inputCorrectCMDFails] :
        [QIN, S, QOUT ] => [ nil, S, 'Command 'application 'failed ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ not (applyCommand(downTerm(Term, noop), S) :: CommandResult) .

    crl [inputAmbiguous] :
        [ QIN, S, QOUT ] => [ Term, S,
          'Ambiguous 'parse. 'Choosing 'first: '\n
          Term '\n ]
      if QIN =/= nil
      /\ ambiguity({Term, Type}, T) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    crl [proved] :
        [QIN, S ^ goals(mt), QOUT]
      =>
        [QIN, S',
          QOUT'' '\n
          'All 'proof 'goals 'discharged '\n
          QOUT']
      if QOUT' := applyCommand(cp, S ^ goals(mt))
      /\ < S' # QOUT'' > := applyCommand(dp, S ^ goals(mt)) .

    crl [emptyProofState] :
        [ QIN, S, QOUT ] => [nil, S,
          'ERROR: 'There 'is 'no 'proof 'in 'progress '\n
          'try 'begin 'proof 'of 'PATTERN'
          ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ noProof := applyCommand(downTerm(Term, noop), S) .

    crl [inputFail] :
        [ QIN, S, QOUT ] => [ nil, S,
          'ERROR 'on 'input: QIN '\n
          'Parsing 'failed 'at 'column pretty(N:Nat)
          ]
      if QIN =/= nil
      /\ noParse(N:Nat) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    op rewriteProofState : ProofState Bound -> ProofState .
    ceq rewriteProofState(ProofState, B:Bound) = downTerm(Term, .ProofState)
      if {Term, Type} := metaRewrite(['AML-PROVER], upTerm(ProofState), B:Bound) .
endm
