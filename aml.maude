fmod VARIABLES is
    protecting NAT .
    protecting QID .
    sorts EVar SVar Var .
    subsort EVar SVar < Var .
    op evar : Qid -> EVar [ctor] . 
    op svar : Qid -> SVar [ctor] .
endfm

fmod AML-CORE is including VARIABLES .
    protecting EXT-BOOL .
*** terse AML Patterns

    sorts Symbol Pattern .
    subsort Var Symbol < Pattern .

    *** Pattern Application
    op _@_  : Pattern Pattern -> Pattern [ctor gather (E e)] .

    *** Patten Implication
    op _-->_  : Pattern Pattern -> Pattern [ctor] .

    *** Bottom
    op bot : -> Pattern [ctor] .

    *** Universal quantification
    op exists_._ : EVar Pattern -> Pattern [ctor] .

    *** least fixpoint
    op mu_._ : SVar Pattern ~> Pattern [ctor] .
    *** condition on set variable fixpoints
    cmb mu X . P : Pattern if positive(X,P) .

    var B : Bool . vars X X' : SVar . vars P Q : Pattern .  var S : Symbol .
    op positive : SVar Pattern -> Bool .
    eq positive(X,P) = $positive(true, X, P) .

    op $positive : Bool SVar Pattern -> Bool .
    eq $positive(B, X, bot) = true .
    eq $positive(B, X, S) = true .
    eq $positive(B, X, X) = B .
    eq $positive(B, X, X') = true .
    eq $positive(B, X, P @ Q) = $positive(B, X, P) and-then $positive(B, X, Q) .
    eq $positive(B, X, P --> Q) = $positive(not B, X, P) and-then $positive(B, X, Q) .
    eq $positive(B, X, exists (x:EVar) . P) = $positive(B, X, P) .
    eq $positive(B, X, mu X . P) = true .
    eq $positive(B, X, mu X' . P) = $positive(B, X, P) .
    
endfm

view Pattern from TRIV to AML-CORE is
    sort Elt to Pattern .
endv

view Symbol from TRIV to AML-CORE is
    sort Elt to Symbol .
endv

view Var from TRIV to AML-CORE is
    sort Elt to Var .
endv

fmod PATTERN-SET is
    pr SET{Pattern} * (sort NeSet{Pattern} to NePatternSet, sort Set{Pattern} to PatternSet) .
endfm
    
fmod AML is including AML-CORE .
*** Add syntactic sugar and variable substitution
*** to AML core representation

    vars P Q P' P'' : Pattern .
    var x : EVar .
    vars X X' : SVar .
    var S : Symbol .
    vars V V' : Var .
    
    *************
    *** Sugar ***

    *** Top
    op top : -> Pattern .
    eq top = exists evar('x) . evar('x) .

    *** Not
    op ~_ : Pattern -> Pattern .
    eq ~ P = P --> bot .

    *** Or, And
    ops _\/_ _/\_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P \/ Q = (~ P) --> Q .
    eq P /\ Q = ~((~ P) \/ (~ Q)) .


    *** If-and-only-if
    op _<-->_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P <--> Q = (P --> Q) /\ (Q --> P) .

    *** Quantifiers
    op forall_._ : EVar Pattern -> Pattern .
    eq forall x . P = ~ (exists x . ~ P ) .

    *** greatest fixpoint
    op nu_._ : EVar Pattern ~> Pattern .
    eq nu X . P = ~ (mu X . ~ (P[~ X / X])) .

    ********************
    *** Substitution ***
    op _[_/_] : Pattern Pattern Var ~> Pattern .

    
    op alphaCapture : -> [Pattern] .
    *** Alpha capture substitution side-condition
    ceq P [Psub / V] = alphaCapture
      if alphaCaptures(V, P, Psub) .

    eq bot[Psub / V] = bot .
    eq S[Psub / V] = S .
    eq V[Psub / V] = Psub .
    eq V'[Psub / V] = V' .

    eq (P @ P')[Psub / V] = (P[Psub / V]) @ (P'[Psub / V]) .

    eq (P --> P')[Psub / V] = P[Psub / V] --> (P'[Psub / V]) .

    eq (exists V . P)[Psub / V] = exists V . P .
    eq (exists V' . P)[Psub / V] = exists V' . (P[Psub  / V]) .

    eq (mu V . P)[Psub / V] = mu V . P .
    eq (mu V' . P)[Psub / V] = mu V' . (P[Psub  / V]) .
    
    op isFreeIn : Var Pattern -> Bool .
    eq isFreeIn(V, V) = true .
    eq isFreeIn(V, V') = false .
    eq isFreeIn(V, S) = false .
    eq isFreeIn(V, P @ P') = isFreeIn(V, P) or-else isFreeIn(V, P') .
    eq isFreeIn(V, P --> P') = isFreeIn(V, P) or-else isFreeIn(V, P') .
    eq isFreeIn(V, exists V . P) = false .
    eq isFreeIn(V, exists V' . P) = isFreeIn(V, P) .
    eq isFreeIn(V, mu V . P) = false .
    eq isFreeIn(V, mu V' . P) = isFreeIn(V, P) .

    var B : Bool .
    var Psub : Pattern .
    var Vb : Var .
    op alphaCaptures : Var Pattern Pattern -> Bool .
    eq alphaCaptures(V, P, Psub) = $alphaCaptures(false, V, P, Psub) .
    
    op $alphaCaptures : Bool Var Pattern Pattern -> Bool .
    eq $alphaCaptures(B, Vb, Vb, Psub) = B .
    eq $alphaCaptures(B, Vb, V', Psub) = false .

    eq $alphaCaptures(B, Vb, S, Psub) = false .

    eq $alphaCaptures(B, Vb, P @ P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, P --> P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, exists Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, exists V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .

    eq $alphaCaptures(B, Vb, mu Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, mu V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .
endfm
