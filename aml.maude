**********************************
*** Applicative Matching Logic ***
*** Interactive Theorem Prover ***
**********************************

in checker/checker/maude/checker.maude

fmod AML-CHECKER is
    extending CHECKER * (sort Rule to AMLRule, op ___;_ to ___;;_ ) .

    *** avoid applying the equation that erases comments for ease of use
    *** mimmic the operator syntax so printed output can be read by the checker
    sort CommentedProofStep CommentedProof .
    subsort ProofStep < Proof CommentedProofStep < CommentedProof .

    op ___;_ : Id Claim AMLRule String -> CommentedProofStep [ctor] .

    op __ : CommentedProof CommentedProof -> CommentedProof [ctor ditto] .
    op __ : CommentedProof          Proof -> CommentedProof [ctor ditto] .
    op __ :          Proof CommentedProof -> CommentedProof [ctor ditto] .

    *** Explicitly convert back to the original proof constructor
    op stripComments : CommentedProof -> Proof .
    eq stripComments(Pi1 Id Claim Rule ; Comment Pi2) =
        stripComments(Pi1 Id Claim Rule ;; Comment Pi2) .
    eq stripComments(Pi1) = Pi1 [owise] .

    *** Helpers
    ops check check-id check-step : CommentedProof -> Bool .
    eq check(Proof) = check(stripComments(Proof)) .
    eq check-id(Proof) = check-id(stripComments(Proof)) .
    eq check-step(Proof) = check-step(stripComments(Proof)) .

    op getStepNum : CommentedProof ~> Nat .
    eq getStepNum(Pi1 (N) Claim Rule ;) = N .
    eq getStepNum(Pi1 (N) Claim Rule ; Comment) = N .

    *** Non-total, fails for unproved well-formed pattern Ids
    op getClaimId : Id CommentedProof ~> Id .
    eq getClaimId(Id, Pi1 Id' Id Rule ; Pi2) = Id' .
    eq getClaimId(Id, Pi1 Id' Id Rule ; Comment Pi2) = Id' .

    op getStepId : Claim AMLRule CommentedProof ~> Id .
    eq getStepId(Claim, Rule, Pi1 Id Claim Rule ; Pi2) = Id .
    eq getStepId(Claim, Rule, Pi1 Id Claim Rule ; Comment Pi2) = Id .

    op _[_] : CommentedProof Nat ~> Claim .
    eq Proof[I] = Proof[((I)).Id] .
    op _[_] : CommentedProof Id ~> Claim .
    eq (Pi1 Id Claim Rule ; Pi2) [Id] = Claim .
    eq (Pi1 Id Claim Rule ; Comment Pi2) [Id] = Claim .

    sorts VariableClaim BasicClaim .
    subsorts VariableClaim < BasicClaim < Claim .
    ops `(\evar`) `(\svar`) : -> VariableClaim .
    op  `(\symb`) : -> BasicClaim .

    sort ProofAndIndex .
    op {_,_} : CommentedProof Id -> ProofAndIndex .
    op getProof : ProofAndIndex -> CommentedProof .
    eq getProof({Proof, Id}) = Proof .

    op appendProofStep : Claim AMLRule CommentedProof -> ProofAndIndex .
    ceq  appendProofStep(BasicClaim, Rule, Proof) =
        { Proof (N) BasicClaim Rule ;, (N) }
      if N := s getStepNum(Proof) .
    ceq appendProofStep(Claim, Rule, Proof) =
        { Proof, Id }
      if Id := getStepId(Claim, Rule, Proof) [owise] .
    ceq appendProofStep(Claim, Rule, Proof) =
        { Proof (N) Claim Rule ;, (N) }
      if N := s getStepNum(Proof) [owise] .

    vars N M I : Nat .
    vars Id Id' : Id .
    var Comment : String .
    var BasicClaim : BasicClaim .
    vars Claim : Claim .
    var Rule : AMLRule .
    vars Pi1 Pi2 Proof : CommentedProof .
endfm

******************************
*** AML Syntax Definitions ***
******************************
fmod VARIABLES is protecting QID + AML-CHECKER .
    sorts EVar SVar Var .
    subsort EVar SVar < Var .
    op evar : Qid -> EVar [ctor] .
    op svar : Qid -> SVar [ctor] .

    op getVarName : Var -> Qid .
    eq getVarName(evar(Q)) = Q .
    eq getVarName(svar(Q)) = Q .

    op getVarType : Var -> Claim .
    eq getVarType(EV) = (\evar) .
    eq getVarType(SV) = (\svar) .

    var Q : Qid .
    var EV : EVar .
    var SV : SVar .
endfm

*** Terse AML pattern syntax
fmod AML-CORE is protecting VARIABLES + EXT-BOOL .
    sorts Symbol Pattern .
    subsort Var Symbol < Pattern .

    *** Bottom _|_
    op bot : -> Pattern [ctor] .

    *** Pattern Application
    op _@_ : Pattern Pattern -> Pattern
          [ctor prec 40  gather (E e) format (d s ++s --)] .

    *** Patten Implication
    op _-->_ : Pattern Pattern -> Pattern [ctor gather (e E) format (d s s++ --)] .

    *** Universal quantification
    op exists_._ : EVar Pattern -> Pattern [ctor prec 42 format (d s s s++ --)] .

    *** least fixpoint
    op mu_._ : SVar Pattern ~> Pattern [ctor prec 42 format (d s s s++ --)] .

    *** condition on set variable fixpoints
    cmb mu X . P : Pattern if nonNegative(X, P) .

    *** Application Contexts
    sort ApplicationContext .
    op [] : -> ApplicationContext [ctor] .
    op _@_ : Pattern ApplicationContext -> ApplicationContext
          [ctor prec 40  gather (E e) format (d s ++s --)] .
    op _@_ : ApplicationContext Pattern -> ApplicationContext
          [ctor prec 40  gather (E e) format (d s ++s --)] .

    *** Predicates
    op nonNegative : SVar Pattern -> Bool .
    eq nonNegative(X,P) = $nonNegative(true, X, P) .

    op $nonNegative : Bool SVar Pattern -> Bool .
    eq $nonNegative(B, X, bot) = true .
    eq $nonNegative(B, X, S) = true .
    eq $nonNegative(B, X, X) = B .
    eq $nonNegative(B, X, V) = true [owise] .
    eq $nonNegative(B, X, P @ Q) = $nonNegative(B, X, P) and-then $nonNegative(B, X, Q) .
    eq $nonNegative(B, X, P --> Q) = $nonNegative(not B, X, P) and-then $nonNegative(B, X, Q) .
    eq $nonNegative(B, X, exists (x:EVar) . P) = $nonNegative(B, X, P) .
    eq $nonNegative(B, X, mu X . P) = true .
    eq $nonNegative(B, X, mu X' . P) = $nonNegative(B, X, P) .

    var B : Bool .
    vars X X' : SVar .
    vars V : Var .
    var S : Symbol .
    vars P Q : Pattern .
endfm

fmod AML is protecting AML-CORE .
*** Add syntactic sugar and substitution
*** to AML core representation

*********************
*** Pattern Sugar ***
*********************

    *** Top
    op top : -> Pattern .
    eq top = exists evar('x) . evar('x) .

    *** Not
    op ~_ : Pattern -> Pattern .
    eq ~ P = P --> bot .

    *** Or, And
    ops _\/_ _/\_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P \/ Q = (~ P) --> Q .
    eq P /\ Q = ~ (P --> ~ Q) .

    *** If-and-only-if
    op _<-->_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P <--> Q = (P --> Q) /\ (Q --> P) .

    *** Quantifiers
    op forall_._ : EVar Pattern -> Pattern .
    eq forall x . P = ~ (exists x . ~ P ) .

    *** greatest fixpoint
    op nu_._ : SVar Pattern -> Pattern .
    eq nu X . P = ~ (mu X . ~ (P[~ X / X])) .

********************
*** Substitution ***
********************

    *** Pattern Substitution
    op _[_/_] : Pattern Pattern Var ~> Pattern [prec 39].

    *** Alpha capture substitution side-condition
    ceq P [Psub / V] =  $ P [Psub / V]
      if not alphaCaptures(V, P, Psub) .

    *** non-capture avoiding Pattern substitution
    op $_[_/_] : Pattern Pattern Var -> Pattern .
    eq $ bot [Psub / V] = bot .
    eq $ S [Psub / V] = S .
    eq $ V [Psub / V] = Psub .
    eq $ V' [Psub / V] = V' .

    eq $ (P @ Q) [Psub / V] = ($ P[Psub / V]) @ ($ Q[Psub / V]) .

    eq $ (P --> Q)[Psub / V] = $ P[Psub / V] --> ($ Q[Psub / V]) .

    eq $ (exists V . P)[Psub / V] = exists V . P .
    eq $ (exists V' . P)[Psub / V] = exists V' . ($ P[Psub  / V]) .

    eq $ (mu V . P)[Psub / V] = mu V . P .
    eq $ (mu V' . P)[Psub / V] = mu V' . ($ P[Psub  / V]) .

    *** Application Context Substitution
    op _[_] : ApplicationContext Pattern -> Pattern .
    eq [] [Psub] = Psub .
    eq Ctx @ Q [Psub] = (Ctx[Psub]) @ Q .
    eq P @ Ctx [Psub] = P @ (Ctx[Psub]) .


    op alphaCaptures : Var Pattern Pattern -> Bool .
    eq alphaCaptures(V, P, Psub) = $alphaCaptures(false, V, P, Psub) .

    op $alphaCaptures : Bool Var Pattern Pattern -> Bool .
    eq $alphaCaptures(B, V, V, Psub) = B .

    eq $alphaCaptures(B, V, bot, Psub) = false .

    eq $alphaCaptures(B, V, V', Psub) = false .

    eq $alphaCaptures(B, V, S, Psub) = false .

    eq $alphaCaptures(B, V, P @ Q, Psub) =
        $alphaCaptures(B, V, P, Psub) or-else $alphaCaptures(B, V, Q, Psub) .

    eq $alphaCaptures(B, V, P --> Q, Psub) =
        $alphaCaptures(B, V, P, Psub) or-else $alphaCaptures(B, V, Q, Psub) .

    eq $alphaCaptures(B, V, exists V . P, Psub) = false .
    eq $alphaCaptures(B, V, exists V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), V, P, Psub) .

    eq $alphaCaptures(B, V, mu V . P, Psub) = false .
    eq $alphaCaptures(B, V, mu V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), V, P, Psub) .

    *** Free Variable Predicate
    op isFreeIn : Var Pattern -> Bool .
    eq isFreeIn(V, bot) = false .
    eq isFreeIn(V, V') = V == V' .
    eq isFreeIn(V, S) = false .
    eq isFreeIn(V, P @ Q) = isFreeIn(V, P) or-else isFreeIn(V, Q) .
    eq isFreeIn(V, P --> Q) = isFreeIn(V, P) or-else isFreeIn(V, Q) .
    eq isFreeIn(V, exists V . P) = false .
    eq isFreeIn(V, exists V' . P) = isFreeIn(V, P) .
    eq isFreeIn(V, mu V . P) = false .
    eq isFreeIn(V, mu V' . P) = isFreeIn(V, P) .

    var B : Bool .
    var x : EVar .
    vars X : SVar .
    vars V V' : Var .
    var S : Symbol .
    vars P Q Psub : Pattern .
    var Ctx : ApplicationContext .
endfm

view Pattern from TRIV to AML is sort Elt to Pattern . endv
view Symbol  from TRIV to AML is sort Elt to Symbol  . endv
view Var     from TRIV to AML is sort Elt to Var     . endv

fmod PATTERN-LIST is
    inc LIST{Pattern} *
        ( sort NeList{Pattern} to NePatternList
        , sort List{Pattern} to PatternList
        ) .
endfm

*** Useful string-like conversions
fmod PRETTY is pr AML .
    pr META-LEVEL .

    *** Natural Numbers
    op pretty : Nat -> QidList .
    eq pretty(N:Nat) = metaPrettyPrint(['NAT], upTerm(N:Nat)) .

    *** Patterns
    op pretty : Pattern -> QidList .
    eq pretty(P:Pattern) =
        metaPrettyPrint(['AML-USER-THEORY], upTerm(P:Pattern)) .
endfm

in aml-user-theory.maude

**********************
*** Prover Modules ***
**********************
mod AML-GOAL is including AML .
    pr PRETTY .
    pr PATTERN-LIST .
    sorts ConsequentMap AntecedentMap .

    op mt : -> AntecedentMap [ctor] .
    op mt : -> ConsequentMap [ctor] .
    op [-_`(_`):_] : Nat Nat Pattern -> AntecedentMap [ctor format (d s d s d d d n++i -- d) ] .
    op  [_`(_`):_] : Nat Nat Pattern -> ConsequentMap [ctor format (d sss s d d d n++i -- d) ] .
    op _;_ : AntecedentMap AntecedentMap -> AntecedentMap [ctor assoc id: mt format (d s n d) ] .
    op _;_ : ConsequentMap ConsequentMap -> ConsequentMap [ctor assoc id: mt format (d s n d) ] .

    sort Goal .
    op _|-_ : AntecedentMap ConsequentMap -> Goal [ctor prec 100 format (d nt n d)] .
    op proved : Pattern Id Id -> Goal [ctor] .

    sort GoalMap .
    op mt : -> GoalMap [ctor] .
    op [_`(_`):_] : Nat Nat Goal -> GoalMap [ctor] .
    op _;_ : GoalMap GoalMap -> GoalMap [ctor assoc id: mt] .

*** Antecedent Map Invariant
*** requires: exists a (-1) indexed element in the map
    crl [antecedentMapInvariant] :
        [- N (I): P] ; [- M (I'): P'] => [- s M (I): P] ; [- M (I'): P']
      if N == M or N > s M .

*** Consequent and Goal Map invariants
*** requires: exists a 0 indexed element in the map
    crl [consequentMapInvariant] :
        [N (I): P] ; [M (I'): P'] => [N (I): P] ; [s N (I'): P']
      if M == N or M > s N .

    crl [goalMapInvariant] :
        [N (I): G] ; [M (I'): G'] => [N (I): G] ; [s N (I'): G']
      if M == N or M > s N .

    *** Print a GoalMap
    op pretty : GoalMap -> QidList .
    eq pretty([N (I): AM |- [0 (I): P]; CM] ; GM) =
        pretty(N) ': '... '|- pretty(P) '\n
        pretty(GM) .
    eq pretty(mt) = nil .

    op fresh : AntecedentMap -> Nat .
    eq fresh((mt).AntecedentMap) = 1 .
    eq fresh([- N (I): P] ; AM) = s N .

    op fresh : ConsequentMap -> Nat .
    eq fresh((mt).ConsequentMap) = 0 .
    eq fresh(CM ; [N (I): P]) = N .

    vars N M I I' : Nat .
    vars P P' Conclusion : Pattern .
    var PL : PatternList .
    var AM : AntecedentMap .
    var CM : ConsequentMap .
    vars G G' : Goal .
    var GM : GoalMap .
endm

*** Module to metaPrettyPrint all user space AML symbols and Proof goals
*** useful for more efficient meta-representation of module to print in
mod PRINT-AML-GOAL is protecting AML-GOAL + AML-USER-THEORY . endm

mod AML-PROOF-STATE is pr PRINT-AML-GOAL .

    pr MAP{Symbol, Nat} * ( op undefined to undefinedSym, op _|->_ to _|-S>_ ) .
    pr MAP{Var, Nat} * ( op undefined to undefinedVar, op _|->_ to _|-V>_ ) .

    sort ProofState .
    op .ProofState : -> ProofState [ctor] .
    op _^_ : ProofState ProofState -> ProofState [assoc comm ctor format (d ni s d)] .

    *** Map of proof goals, associating a list index and a unique index
    *** 0th element of list is the current proof goal
    op goals : GoalMap -> ProofState [ctor format (++ --)] .

    *** Map associating AML symbols to their Well-formedness claim in proof
    op symbolIndex : Map{Symbol,Nat} -> ProofState [ctor] .

    *** Map associating AML variables to their Well-formedness claim in proof
    op variableIndex : Map{Var,Nat} -> ProofState [ctor] .

    *** intermediate hilbrt proof
    op hilbertProof : CommentedProof -> ProofState [ctor] .

    *** build a ProofState given a target pattern and a list of assumptions
    op initializeProofState : PatternList Pattern -> ProofState .
    eq initializeProofState(Assumptions, Conclusion) =
        hilbertProof((0) (\bot) (WF) ;) ^
        symbolIndex(empty) ^
        variableIndex(empty) ^
        goals( [ 0 (0): mt |- [ 0 (0): makeClaim(Assumptions,Conclusion) ] ] ) .

    *** build an implication pattern out of a list of asummptions and a conclusion
    op makeClaim : PatternList Pattern -> Pattern .
    eq makeClaim(nil, Conclusion) = Conclusion .
    eq makeClaim(P PL, Conclusion) = P --> makeClaim(PL, Conclusion) .

    *** GoalMap precondition, there is always a 0-indexed goal
    crl [gmPre] : goals([N (I): Goal] ; GM ) => goals([0 (I): Goal] ; GM)
      if N > 0 .

    *** Projections
    op getProof : ProofState ~> CommentedProof .
    eq getProof(hilbertProof(Proof) ^ ProofState) = Proof .

    op getVariableIndex : ProofState ~> Map{Var,Nat} .
    eq getVariableIndex(ProofState ^ variableIndex(VM)) = VM .

    op getGoal : Nat ProofState ~> Goal .
    eq getGoal(GIndex, ProofState ^ goals(GM1 ; [GIndex (GI): Goal] ; GM2)) = Goal .

    *** Modifiers
    op appendAntecedent : Nat Id Pattern ProofState ~> ProofState .
    ceq appendAntecedent(GIndex, Id, P, ProofState) = ProofState
      if AM1 ; [- N (I): P] ; AM2 |- CM := getGoal(GIndex, ProofState) .
    eq appendAntecedent(GIndex, (WfI), P,
        ProofState ^
        goals(GM1 ; [GIndex (GI):                          AM |- CM] ; GM2))
      =
        ProofState ^
        goals(GM1 ; [GIndex (GI): [- fresh(AM) (WfI): P] ; AM |- CM] ; GM2)
        [owise] .

    *** Return Sort for Proof modifiers, modified state,
    *** and the relevant Proof Id modified
    sort ProofStateAndIndex .
    op {_,_} : ProofState Id -> ProofStateAndIndex .
    op getProofState : ProofStateAndIndex -> ProofState .
    eq getProofState({ProofState, Id}) = ProofState .

    op appendProofStep : Claim AMLRule ProofState -> ProofStateAndIndex .
    ceq appendProofStep(Claim, Rule, ProofState ^ hilbertProof(Proof)) =
          {ProofState ^ hilbertProof(Proof'), Id}
      if {Proof', Id} := appendProofStep(Claim, Rule, Proof) .


    vars N I WfI GI GIndex : Nat .
    vars Id : Id .
    var Claim : Claim . var Rule : AMLRule .
    vars P Conclusion : Pattern .
    vars PL Assumptions : PatternList .
    vars Proof Proof' : CommentedProof .
    vars AM AM1 AM2 : AntecedentMap .
    var CM : ConsequentMap .
    var Goal : Goal .
    vars GM GM1 GM2 : GoalMap .
    vars VM : Map{Var,Nat} .
    vars ProofState ProofState' : ProofState .
endm

*** Useful sub-proofs for AML proofs
mod AML-PROOF-LEMMAS is pr AML-PROOF-STATE .

    *** Identity Implication Tautology (P -> P)
    op propILemma : Nat Id -> ProofAndIndex .
    eq propILemma(N, WfId) =
        { (     N) (\imp WfId WfId)        (WF) ; "begin propILemma"
                                                  ***| P -> P
          (1  + N) (\imp WfId (N))         (WF) ; ***| P -> (P -> P)
          (2  + N) (1 + N)              (PropK) ; ***| PropK P P
          (3  + N) (\imp (N) WfId)         (WF) ; ***| (P -> P) -> P
          (4  + N) (\imp WfId (3 + N))     (WF) ; ***| P -> ((P -> P) -> P)
          (5  + N) (4 + N)              (PropK) ; ***| PropK P (P -> P)
          (6  + N) (\imp (1 + N) (N))      (WF) ; ***| (P -> (P -> P)) -> (P -> P)
          (7  + N) (\imp (4 + N) (6 + N))  (WF) ; ***| (P -> ((P -> P) -> P))
                                                  ***  -> ((P -> (P -> P)) -> (P -> P))
          (8  + N) (7 + N)              (PropS) ; ***| PropS P (P -> P) P
          (9  + N) (6 + N) (MP (5 + N) (8 + N)) ; ***| MP 5 8
          (10 + N) (    N) (MP (2 + N) (9 + N)) ; ***| MP 2 9
                                                  "end propILemma"
          , (N) } .

    op  wfPatternLemma : Pattern ProofState ~> ProofStateAndIndex .

    eq  wfPatternLemma(bot, PrSt) = {PrSt, (0)} .

    ceq wfPatternLemma(V, variableIndex(VM) ^ PrSt) =
        { variableIndex(VM) ^ PrSt, (M) }
      if M := VM[V] .

    ceq wfPatternLemma(V, variableIndex(VM) ^ hilbertProof(Proof) ^ PrSt) =
        { variableIndex((VM, V |-V> N)) ^
            hilbertProof(Proof (N) getVarType(V) (WF) ; string(getVarName(V))) ^
            PrSt
            , (N) }
      if undefinedVar := VM[V] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ PrSt)  =
        { symbolIndex(SM) ^ PrSt, (M) }
      if M := SM[S] .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ hilbertProof(Proof) ^ PrSt) =
        { symbolIndex((SM, S |-S> N)) ^
            hilbertProof(Proof (N) (\symb) (WF) ; string(pretty(S))) ^
            PrSt
            , (N) }
      if undefinedSym := SM[S] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(exists EV . P, PrSt) =
        appendProofStep((\ex Id1 Id2), (WF), PrSt2)
      if {PrSt', Id1} := wfPatternLemma(EV, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(P, PrSt') .

    ceq wfPatternLemma(mu SV . P, PrSt) =
        appendProofStep((\mu Id1 Id3), (WFMu Id2), PrSt3)
      if {PrSt', Id1} := wfPatternLemma(SV, PrSt)
      /\ {PrSt2, Id2} := nonNegativeLemma(SV, P, PrSt')
      /\ {PrSt3, Id3} := wfPatternLemma(P, PrSt2) .

    ceq wfPatternLemma(P @ P', PrSt) =
        appendProofStep((\app Id1 Id2), (WF), PrSt2)
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(P', PrSt') .

    ceq wfPatternLemma(P --> P', PrSt) =
        appendProofStep((\imp Id1 Id2), (WF), PrSt2)
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(P', PrSt') .

    op wfApplicationContextLemma : Id ApplicationContext ProofState -> ProofStateAndIndex .
    eq wfApplicationContextLemma(VId, [], PrSt) = {PrSt, VId} .

    ceq wfApplicationContextLemma(VId, Ctx @ Q, PrSt) =
        appendProofStep((\app Id1 Id2), (WF),PrSt2)
      if {PrSt', Id1} := wfApplicationContextLemma(VId, Ctx, PrSt)
      /\ {PrSt2, Id2} := wfPatternLemma(Q, PrSt') .

    ceq wfApplicationContextLemma(VId, P @ Ctx, PrSt) =
        appendProofStep((\app Id1 Id2), (WF),PrSt2)
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt2, Id2} := wfApplicationContextLemma(VId, Ctx, PrSt') .

    *** Side Conditions
    *** #nno : Non negative set variable occurence
    op nonNegativeLemma : SVar Pattern ProofState ~> ProofStateAndIndex .
    ceq nonNegativeLemma(SV, P, PrSt) =
        {PrSt2 ^ hilbertProof(Proof'), NNOId}
      if {PrSt', XId} := wfPatternLemma(SV, PrSt)
      /\ {PrSt2 ^ hilbertProof(Proof), PId} := wfPatternLemma(P, PrSt)
      /\ {Proof', NNOId} := nonNegativeLemma(XId, PId, Proof) .

    op nonNegativeLemma : Id Id CommentedProof ~> ProofAndIndex .
    eq nonNegativeLemma(XId, (0), Proof) =
        appendProofStep((#nno (0) XId), (NNOBasic), Proof) .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOBasic), Proof)
      if BasicClaim := Proof[PId] .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOImp NPOId NNOId), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', NPOId} := nonPositiveLemma(XId, Id1, Proof)
      /\ {Proof2, NNOId} := nonNegativeLemma(XId, Id2, Proof') .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOApp NNOId1 NNOId2), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', NNOId1} := nonNegativeLemma(XId, Id1, Proof)
      /\ {Proof2, NNOId2} := nonNegativeLemma(XId, Id2, Proof') .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOEx NNOId), Proof')
      if (\ex Id1 Id2) := Proof[PId]
      /\ {Proof', NNOId} := nonNegativeLemma(XId, Id2, Proof) .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOMuBinding), Proof)
      if (\mu XId Id1) := Proof[PId] .

    ceq nonNegativeLemma(XId, PId, Proof) =
          appendProofStep((#nno PId XId), (NNOMuBody NNOId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NNOId} := nonNegativeLemma(XId, Id, Proof) .

    op nonPositiveLemma : Id Id CommentedProof ~> ProofAndIndex .
    eq nonPositiveLemma(XId, (0), Proof) =
        appendProofStep((#npo (0) XId), (NPOBasic), Proof) .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOBasic), Proof)
      if BasicClaim := Proof[PId] /\ XId =/= PId .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOImp NNOId NPOId), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', NNOId} := nonNegativeLemma(XId, Id1, Proof)
      /\ {Proof2, NPOId} := nonPositiveLemma(XId, Id2, Proof') .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOApp NPOId1 NPOId2), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', NPOId1} := nonPositiveLemma(XId, Id1, Proof)
      /\ {Proof2, NPOId2} := nonPositiveLemma(XId, Id2, Proof') .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOEx NPOId), Proof')
      if (\ex Id1 Id2) := Proof[PId]
      /\ {Proof', NPOId} := nonPositiveLemma(XId, Id2, Proof) .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOMuBinding), Proof)
      if (\mu XId Id1) := Proof[PId] .

    ceq nonPositiveLemma(XId, PId, Proof) =
          appendProofStep((#npo PId XId), (NPOMuBody NPOId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NPOId} := nonPositiveLemma(XId, Id, Proof) .

    *** #nf : free variable capture avoidance
    op notFreeLemma : Var Pattern ProofState ~> ProofStateAndIndex .
    ceq notFreeLemma(V, P, PrSt) = {PrSt2 ^ hilbertProof(Proof'), NFId}
      if {PrSt', XId} := wfPatternLemma(V, PrSt)
      /\ {PrSt2 ^ hilbertProof(Proof), PId} := wfPatternLemma(P, PrSt')
      /\ {Proof', NFId} := notFreeLemma(XId, PId, Proof) .

    op notFreeLemma : Id Id CommentedProof ~> ProofAndIndex .
    eq notFreeLemma(XId, (0), Proof) =
        appendProofStep((#nf XId (0)), (NFBasic), Proof) .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFBasic), Proof)
      if BasicClaim := Proof[PId] /\ PId =/= XId .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFImp NFId1 NFId2), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', NFId1} := notFreeLemma(XId, Id1, Proof)
      /\ {Proof2, NFId2} := notFreeLemma(XId, Id2, Proof') .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFApp NFId1 NFId2), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', NFId1} := notFreeLemma(XId, Id1, Proof)
      /\ {Proof2, NFId2} := notFreeLemma(XId, Id2, Proof') .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFExBinding), Proof)
      if (\ex XId Id2) := Proof[PId] .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFExBody NFId), Proof')
      if (\ex YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NFId} := notFreeLemma(XId, Id, Proof) .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFMuBinding), Proof)
      if (\mu XId Id2) := Proof[PId] .

    ceq notFreeLemma(XId, PId, Proof) =
        appendProofStep((#nf XId PId), (NFMuBody NFId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ YId =/= XId
      /\ {Proof', NFId} := notFreeLemma(XId, Id, Proof) .

    *** #subst : Pattern substitution
    op substitutionLemma : Pattern Pattern Pattern Var ProofState ~> ProofStateAndIndex .
    ceq substitutionLemma(R, P, Q, X, PrSt) =
        {PrSt4 ^ hilbertProof(Proof'), SubId}
      if {PrSt', RId} := wfPatternLemma(R, PrSt)
      /\ {PrSt2, PId} := wfPatternLemma(P, PrSt')
      /\ {PrSt3, QId} := wfPatternLemma(Q, PrSt2)
      /\ {PrSt4 ^ hilbertProof(Proof), XId} := wfPatternLemma(X, PrSt3)
      /\ {Proof', SubId} := substitutionLemma(RId, PId, QId, XId, Proof) .

    op substitutionLemma : Id Id Id Id ProofState ~> ProofStateAndIndex .
    ceq substitutionLemma(RId, PId, QId, XId, PrSt ^ hilbertProof(Proof)) =
        {PrSt ^ hilbertProof(Proof'), SubId}
      if {Proof', SubId} := substitutionLemma(RId, PId, QId, XId, Proof) .

    op substitutionLemma : Id Id Id Id CommentedProof ~> ProofAndIndex .

    eq substitutionLemma((0), (0), QId, XId, Proof) =
        appendProofStep((#subst (0) (0) QId XId), (SubstBot), Proof) .

    ceq substitutionLemma(PId, PId, QId, XId, Proof) =
        appendProofStep((#subst PId PId QId XId), (SubstSymb), Proof)
      if Proof[PId] == (\symb) .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstVariable), Proof)
      if Proof[PId] :: VariableClaim /\ (PId == XId and RId == QId) or PId =/= XId  .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstImp SubId1 SubId2), Proof2)
      if (\imp PId1 PId2) := Proof[PId]
      /\ (\imp RId1 RId2) := Proof[RId]
      /\ {Proof', SubId1} := substitutionLemma(RId1, PId1, QId, XId, Proof)
      /\ {Proof2, SubId2} := substitutionLemma(RId2, PId2, QId, XId, Proof') .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstApp SubId1 SubId2), Proof2)
      if (\app PId1 PId2) := Proof[PId]
      /\ (\app RId1 RId2) := Proof[RId]
      /\ {Proof', SubId1} := substitutionLemma(RId1, PId1, QId, XId, Proof)
      /\ {Proof2, SubId2} := substitutionLemma(RId2, PId2, QId, XId, Proof') .

    ceq substitutionLemma(PId, PId, QId, XId, Proof) =
        appendProofStep((#subst PId PId QId XId), (SubstExBinding), Proof)
      if (\ex XId RId) := Proof[PId] .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep(
          (#subst RId PId QId XId),
          (SubstExBody FVId NFId SubId1 SubId2),
          Proof4)
      if (\ex YId PId1) := Proof[PId] /\ YId =/= XId
      /\ (\ex FVId RId2) := Proof[RId] /\ FVId =/= XId
      /\ {Proof', NFId} := notFreeLemma(FVId, QId, Proof)
      /\ {Proof2, RId1} := wfSubstitutionLemma(PId1, FVId, YId, Proof')
      /\ {Proof3, SubId1} := substitutionLemma(RId1, PId1, FVId, YId, Proof2)
      /\ {Proof4, SubId2} := substitutionLemma(RId2, RId1, QId, XId, Proof3) .

    ceq substitutionLemma(PId, PId, QId, XId, Proof) =
        appendProofStep((#subst RId PId QId XId), (SubstMuBinding), Proof)
      if (\mu XId RId) := Proof[PId] .

    ceq substitutionLemma(RId, PId, QId, XId, Proof) =
        appendProofStep(
          (#subst RId PId QId XId),
          (SubstMuBody FVId NFId SubId1 SubId2),
          Proof4)
      if (\mu YId PId1) := Proof[PId] /\ YId =/= XId
      /\ (\mu FVId RId2) := Proof[RId] /\ FVId =/= XId
      /\ {Proof', NFId} := notFreeLemma(FVId, QId, Proof)
      /\ {Proof2, RId1} := wfSubstitutionLemma(PId1, FVId, YId, Proof')
      /\ {Proof3, SubId1} := substitutionLemma(RId1, PId1, FVId, YId, Proof2)
      /\ {Proof4, SubId2} := substitutionLemma(RId2, RId1, QId, XId, Proof3) .

    *** Needed to be able to calculate the result of substituiton for a
    *** fresh variable generated at the proof level.
    *** basically duplicates `wfPatternLemma(P[Q / X], ProofState)`
    *** but there is no pattern-level way to generate a fresh variable (TODO)
    op wfSubstitutionLemma : Id Id Id ProofState -> ProofStateAndIndex .
    ceq wfSubstitutionLemma(PId, QId, XId, PrSt ^ hilbertProof(Proof)) =
        {PrSt ^ hilbertProof(Proof'), WfId}
      if {Proof', WfId} := wfSubstitutionLemma(PId, QId, XId, Proof) .

    op wfSubstitutionLemma : Id Id Id CommentedProof -> ProofAndIndex .
    eq wfSubstitutionLemma((0), QId, XId, Proof) = {Proof, (0)} .
    eq wfSubstitutionLemma(XId, QId, XId, Proof) = {Proof, QId} .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) = {Proof, PId}
      if Proof[PId] :: BasicClaim /\ PId =/= XId .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\imp SubId1 SubId2), (WF), Proof2)
      if (\imp Id1 Id2) := Proof[PId]
      /\ {Proof', SubId1} := wfSubstitutionLemma(Id1, QId, XId, Proof)
      /\ {Proof2, SubId2} := wfSubstitutionLemma(Id2, QId, XId, Proof') .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\app SubId1 SubId2), (WF), Proof2)
      if (\app Id1 Id2) := Proof[PId]
      /\ {Proof', SubId1} := wfSubstitutionLemma(Id1, QId, XId, Proof)
      /\ {Proof2, SubId2} := wfSubstitutionLemma(Id2, QId, XId, Proof') .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) = {Proof, PId}
      if (\ex XId Id) := Proof[PId] .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\ex YId SubId), (WF), Proof')
      if (\ex YId Id) := Proof[PId]
      /\ {Proof', SubId} := wfSubstitutionLemma(Id, QId, XId, Proof) .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) = {Proof, PId}
      if (\mu XId Id) := Proof[PId] .
    ceq wfSubstitutionLemma(PId, QId, XId, Proof) =
        appendProofStep((\ex YId SubId), (WFMu NNOId), Proof')
      if (\mu YId Id) := Proof[PId]
      /\ {Proof', SubId} := wfSubstitutionLemma(Id, QId, XId, Proof)
      /\ {Proof2, NNOId} := nonNegativeLemma(YId, Id, Proof') .

    *** #appctx Application context pattern side conditions
    op applicationContextLemma : ApplicationContext ProofState ~> ProofStateAndIndex .
    ceq applicationContextLemma(Ctx, PrSt) =
        applicationContextLemma(VId, Ctx, PrSt')
      if {PrSt', VId} := appendProofStep((\evar), (WF), PrSt) .

    op applicationContextLemma : Id ApplicationContext ProofState ~> ProofStateAndIndex .
    ceq applicationContextLemma(VId, Ctx, PrSt) =
        {PrSt2 ^ hilbertProof(Proof'), ACId}
      if {PrSt', WfId} := wfApplicationContextLemma(VId, Ctx, PrSt)
      /\ PrSt2 ^ hilbertProof(Proof) := PrSt'
      /\ {Proof', ACId} := applicationContextLemma(VId, Ctx, WfId, Proof) .

    op applicationContextLemma : Id ApplicationContext Id CommentedProof ~> ProofAndIndex .

    eq applicationContextLemma(VId, [], VId, Proof) =
        appendProofStep((#appctx VId VId), (AppCtxInit), Proof) .

    ceq applicationContextLemma(VId, Ctx @ Q, Id, Proof) =
        appendProofStep((#appctx Id VId), (AppCtxL ACId NFId), Proof2)
      if (\app CtxId QId) := Proof[Id]
      /\ {Proof', NFId} := notFreeLemma(VId, QId, Proof)
      /\ {Proof2, ACId} := applicationContextLemma(VId, Ctx, CtxId, Proof') .

    ceq applicationContextLemma(VId, P @ Ctx, Id, Proof) =
        appendProofStep((#appctx Id VId), (AppCtxR ACId NFId), Proof2)
      if (\app PId CtxId) := Proof[Id]
      /\ {Proof', NFId} := notFreeLemma(VId, PId, Proof)
      /\ {Proof2, ACId} := applicationContextLemma(VId, Ctx, CtxId, Proof') .

    vars N N' N2 N3 M M' I WfI : Nat .
    vars Id Id1 Id2 Id3 WfId : Id .
    vars NNOId NNOId1 NNOId2 : Id .
    vars NPOId NPOId1 NPOId2 : Id .
    vars NFId NFId1 NFId2 : Id .
    vars SubId SubId1 SubId2 : Id .
    vars ACId : Id .
    vars PId PId1 PId2 QId RId RId1 RId2 VId XId YId FVId CtxId : Id .
    var S : Symbol .
    vars P P' Q R Sub : Pattern .
    vars Ctx Ctx1 Ctx2 : ApplicationContext .
    var EV : EVar .
    var SV : SVar .
    vars X V : Var .
    var VarClaim : VariableClaim .
    var BasicClaim : BasicClaim .
    var Claim : Claim .
    var Rule : AMLRule .
    vars Proof Proof' Proof2 Proof3 Proof4 Pi1 Pi2 : CommentedProof .
    vars SM : Map{Symbol,Nat} .
    vars VM : Map{Var,Nat} .
    vars AM AM' : AntecedentMap .
    var CM : ConsequentMap .
    vars PrSt PrSt' PrSt2 PrSt3 PrSt4 : ProofState .
endm

fmod SUBSTITUTION is protecting META-LEVEL .
*** Take a Substitution, Like one from a metaXmatch result,
*** and instantiate the matched term.
*** This helps with AML-Pattern Pattern matching in prover commands
    op applySubstitution : Term     Substitution -> Term .
    op applySubstitution : TermList Substitution -> TermList .

    eq applySubstitution(Con, Sub) = Con .

    eq applySubstitution(Var, Var <- T ; Sub) = T .
    eq applySubstitution(Var, Sub) = Var [owise] .

    eq applySubstitution(Operator[Args], Sub) =
        Operator[applySubstitution(Args, Sub)] .

    eq applySubstitution(empty, Sub) = empty .
    eq applySubstitution((T, Ts), Sub) =
        applySubstitution(T, Sub), applySubstitution(Ts, Sub) .

    var Operator : Qid .
    var Var : Variable .
    var Con : Constant .
    var T : Term .
    var Ts : NeTermList .
    vars Args : TermList .
    var Sub : Substitution .
endfm

mod AML-PROVER-COMMANDS is protecting AML-PROOF-LEMMAS + SUBSTITUTION .

*************************
*** Basic UI Commands ***
*************************

    sorts ProverCMD .

    op noop : -> ProverCMD [ctor] .

    *** Proof command that only acts on an empty proofstate
    sort EmptyProofCMD .
    subsort EmptyProofCMD < ProverCMD .
    op begin`proof`of_assuming_ : Pattern PatternList -> EmptyProofCMD [ctor gather (& E)] .
    op begin`proof`of_ : Pattern -> ProverCMD [prec 42] .
    eq begin proof of P = begin proof of P assuming nil .

    op sg_ : Nat -> ProverCMD [ctor] .
    op switch`goal_ : Nat -> ProverCMD .
    eq switch goal N:Nat = sg N:Nat .

    op pp : -> ProverCMD [ctor] .
    op print`proof : -> ProverCMD .
    eq print proof = pp .

    op pg : -> ProverCMD [ctor] .
    op print`goal : -> ProverCMD .
    eq print goal = pg .

    op pgs : -> ProverCMD [ctor] .
    op print`goals : -> ProverCMD .
    eq print goals = pgs .

    op cp : -> ProverCMD [ctor] .
    op check`proof : -> ProverCMD .
    eq check proof = cp .

    op dump`proof : -> ProverCMD [ctor] .

*******************************
*** AML Proof Rule Commands ***
*******************************

    *** Specialize ProverCMD errors when patterns are malformed
    sort PatternProverCMD .
    subsort PatternProverCMD < ProverCMD .

    *** Prop Κ:
    ***  Γ |- Δ
    *** ---------------------
    ***  Γ, P -> Q -> P |- Δ
    op K__ : Pattern Pattern -> PatternProverCMD [ctor prec 42] .
    op propK__ : Pattern Pattern -> PatternProverCMD [prec 42].
    eq propK P Q = K P Q .

    *** Prop S:
    ***  Γ |- Δ
    *** -------------------------------------------------
    ***  Γ, (P -> (Q -> R)) -> (P -> Q) -> (P -> R) |- Δ
    op S___ : Pattern Pattern Pattern -> PatternProverCMD [ctor prec 42] .
    op propS___ : Pattern Pattern Pattern -> PatternProverCMD [prec 42].
    eq propS P Q R = S P Q R .

    *** Prop F:
    ***  Γ |- Δ
    *** ----------------------------------
    ***  Γ, ((P -> _|_) -> _|_) -> P |- Δ
    op F_ : Pattern -> PatternProverCMD [ctor prec 42] .
    op propF_ : Pattern -> PatternProverCMD .
    eq propF P = F P .

    *** Modus Ponens:
    ***  Γ, P, P -> Q |- Δ
    *** ----------------------
    ***  Γ, P, P -> Q, Q |- Δ
    op mp__ : Pattern Pattern -> ProverCMD [ctor] .
    op modus`ponens__ : Pattern Pattern -> ProverCMD .
    eq modus ponens P Q  = mp P Q .

    *** ∃ - Quantifier:
    ***  Γ |- Δ
    *** ---------------------- [ if not (x ∈ FV(P)) ]
    ***  Γ, P -> ∃ x . P |- Δ
    op eq__ : Qid Pattern -> PatternProverCMD [ctor] .
    op existential`quantifier__ : Qid Pattern -> PatternProverCMD .
    eq existential quantifier Q:Qid P = eq Q:Qid P .

    *** ∃ - Generalization:
    ***  Γ, P -> Q |- Δ
    *** ---------------------- [ if not (x ∈ FV(Q)) ]
    ***  Γ, ∃ x . P -> Q |- Δ
    op eg___ : Qid Pattern Pattern -> PatternProverCMD [ctor] .
    op existential`generalization___ : Qid Pattern Pattern -> PatternProverCMD .
    eq existential generalization Q:Qid P Q = eg Q:Qid P Q .

    *** Propagation-_|_
    ***  Γ |- Δ
    *** ------------------------
    ***  Γ, C[_|_] --> _|_ |- Δ
    op lbp_ : Pattern -> PatternProverCMD [ctor] .
    op left`bot`propagation_ : Pattern -> PatternProverCMD .
    eq left bot propagation P = lbp P .

    op rbp_ : Pattern -> PatternProverCMD [ctor] .
    op right`bot`propagation_ : Pattern -> PatternProverCMD .
    eq right bot propagation P = rbp P .

    *** Propagation-\/
    ***  Γ |- Δ
    *** ------------------------------------
    ***  Γ, C[P \/ Q] --> C[P] \/ C[Q] |- Δ
    op lop___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op left`or`propagation___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq left or propagation C:Pattern P Q = lop C:Pattern P Q .

    op rop___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op right`or`propagation___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq right or propagation C:Pattern P Q = rop C:Pattern P Q .

    *** Propagation-∃
    ***  Γ |- Δ
    *** ----------------------------------- [if x not in FV(C)]
    ***  Γ, C[∃ x . P] --> ∃ x . C[P] |- Δ
    op lep___ : Pattern EVar Pattern -> PatternProverCMD [ctor] .
    op left`existential`propagation___ : Pattern EVar Pattern -> PatternProverCMD .
    eq left existential propagation C:Pattern EVar P = lep C:Pattern EVar P .

    op rep___ : Pattern EVar Pattern -> PatternProverCMD [ctor] .
    op right`existential`propagation___ : Pattern EVar Pattern -> PatternProverCMD .
    eq right existential propagation C:Pattern EVar P = rep C:Pattern EVar P .

    *** Framing
    *** Γ, P --> Q |- Δ
    *** -----------------
    *** Γ, C[P] --> C[Q] |- Δ
    op lfr___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op left`framing___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq left framing C:Pattern P Q = lfr C:Pattern P Q .

    op rfr___ : Pattern Pattern Pattern -> PatternProverCMD [ctor] .
    op right`framing___ : Pattern Pattern Pattern -> PatternProverCMD .
    eq right framing C:Pattern P Q = rfr C:Pattern P Q .

    *** Set Variable Substitution
    ***  Γ, P |- Δ
    *** ----------------
    ***  Γ, P[Q/X] |- Δ
    op svs___ : Qid Pattern Pattern -> PatternProverCMD [ctor] .
    op set`variable`substitution___ : Qid Pattern Pattern -> PatternProverCMD .
    eq set variable substitution X:Qid P Q = svs X:Qid P Q .

    *** Pre-fixpoint
    ***  Γ |- Δ
    *** ---------------------------------
    ***  Γ P[μ X . P/X] --> μ X . P |- Δ
    op pfp__ : Qid Pattern -> PatternProverCMD [ctor] .
    op pre`fixpoint__ : Qid Pattern -> PatternProverCMD .
    eq pre fixpoint X:Qid P = pfp X:Qid P .

    *** Knaster-Tarski
    ***  Γ,  P[Q/X] --> Q |- Δ
    *** -----------------------
    ***  Γ, μ X . P --> Q |- Δ
    op kt___ : Qid Pattern Pattern -> PatternProverCMD [ctor] .
    op knaster`tarski___ : Qid Pattern Pattern -> PatternProverCMD .
    eq knaster tarski X:Qid P Q = kt X:Qid P Q .

    *** Existence
    ***  Γ |- Δ
    *** ------------------
    ***  Γ, ∃ x . x, |- Δ
    op ex_ : Qid -> ProverCMD [ctor] .
    op existence_ : Qid -> ProverCMD .
    eq existence Q:Qid = ex Q:Qid .

    *** Singleton
    *** Γ |- Δ
    *** ------------------------------------
    *** Γ, ~ (C1[x /\ P ] /\ C2[x /\ ~ P])
    op sng____ : ApplicationContext ApplicationContext Qid Pattern -> PatternProverCMD [ctor] .
    op singleton____ : ApplicationContext ApplicationContext Qid Pattern -> PatternProverCMD .
    eq singleton Ctx1 Ctx2 Q:Qid P = sng Ctx1 Ctx2 Q:Qid P .

***************************
*** Derived Proof Rules ***
***************************

    *** Prop I (Identity Tautology):
    ***  Γ |- Δ
    *** --------
    ***  Γ, P -> P |- Δ
    op I_ : Pattern -> PatternProverCMD [ctor prec 42] .
    op propI_ : Pattern -> PatternProverCMD [prec 42] .
    eq propI P = I P .

******************************
*** Sequent Calculus Rules ***
******************************

    *** Assert:
    *** ----------
    ***  Γ, ax |- ax, Δ
    op assert : -> ProverCMD [ctor] .

**********************************
*** Prover Command Application ***
    sort CommandResult .
    subsort ProofState QidList < CommandResult .
    op [_#_] : ProofState QidList -> CommandResult [ctor] .
    op noProof : -> CommandResult [ctor] .
    op applyCommand : ProverCMD ProofState -> CommandResult .

*************************
*** Basic UI Commands ***
*************************

    *** Initiate prover loop
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, .ProofState) =
        initializeProofState(Hypotheses, Conclusion) .

    *** Do not overwrite proof with `begin proof`
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, ProofState) =
        ''begin 'proof' 'will 'overwrite 'current 'proof '\n
        'please ''dump 'proof' 'and 'try 'again '\n [owise] .

    *** Empty ProofState
    ceq applyCommand(CMD:ProverCMD, .ProofState) = noProof
      if not (CMD:ProverCMD :: EmptyProofCMD) .

    *** Print Goals
    eq applyCommand(pgs, goals(GM) ^ ProofState) = pretty(GM) .

    *** Print current goal
    eq applyCommand(pg, goals([0 (I): G] ; GM) ^ ProofState) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G))  .

    ceq applyCommand(sg N, goals(GM) ^ ProofState) =
        goals([0 (GI1): G'] ; GM1 ; [N (GI2): G] ; GM2) ^ ProofState
      if [0 (GI2): G] ; GM1 ; [N (GI1): G'] ; GM2 := GM .

    eq applyCommand(sg N, goals(GM) ^ ProofState) =
        'Switch 'goal 'failed '\n
        'Index 'out 'bounds [owise] .

    *** Check Proof
    ceq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
        'Invalid 'Proof 'Index
      if not check-id(Proof) .

    ceq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
        'Proof 'is 'Valid
      if check-step(Proof) [owise] .

    eq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
        metaPrettyPrint(['AML-CHECKER], upTerm(check-step(Proof))) [owise] .

    *** Print Proof
    eq applyCommand(pp, hilbertProof(CommentedProof) ^ ProofState) =
        metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) .

    *** Print proof and start over
    eq applyCommand(dump proof, hilbertProof(CommentedProof) ^ ProofState) =
        [ .ProofState # metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) ] .

***********************
*** AML Proof Rules ***
***********************

    *** PropK
    eq applyCommand(K P Q, ProofState) =
        axiomIntroRule(0, P --> Q --> P, (PropK), ProofState) .

    *** PropS
    eq applyCommand(S P Q R, ProofState) =
        axiomIntroRule(0, (P --> Q --> R) --> (P --> Q) --> (P --> R),
          (PropS), ProofState) .

    *** PropF
    eq applyCommand(F P, ProofState) =
        axiomIntroRule(0, ((P --> bot) --> bot) --> P, (PropF), ProofState) .

    *** Modus Ponens
    ceq applyCommand(mp Ant Con, ProofState) =
        appendAntecedent(0, WfId, Con', ProofState')
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' :=
          amlPatternMatch(
            Ant --> Con,
            upTerm(AM),
            *** Meta-matching side-condition:
            ***     Ant must be an antecedent pattern
            '_;_['AM1:AntecedentMap,
              ('`[-_`(_`):_`]['N:Nat, 'I:Nat, upTerm(Ant)]),
              'AM2:AntecedentMap]
            := upTerm(AM))
      /\ AM1 ; [- N (HypWfI): Ant' --> Con' ] ;
         AM2 ; [- M (AntWfI): Ant' ] ;
         AM3 := AM
      /\ Proof := getProof(ProofState)
      /\ AntClaimId := getClaimId((AntWfI), Proof)
      /\ HypClaimId := getClaimId((HypWfI), Proof)
      /\ (\imp (AntWfI) WfId) := Proof[HypWfI]
      /\ {ProofState', ClaimId} :=
          appendProofStep(WfId, (MP AntClaimId HypClaimId), ProofState) .

    eq applyCommand(mp Ant Con, ProofState) =
        'Modus 'Ponens 'failed [owise] .

    *** ∃-Quantification Axiom
    ceq applyCommand(eq Q:Qid P, ProofState) =
        appendAntecedent(0, WfId, P --> (exists EVar . P), PrSt5)
      if EVar := evar(Q:Qid)
      /\ {PrSt, PId} := wfPatternLemma(P, ProofState)
      /\ {PrSt2, WfId} := wfPatternLemma(P --> (exists EVar . P), PrSt)
      /\ XId := (getVariableIndex(PrSt2)[EVar])
      /\ {PrSt3, FVId} := appendProofStep((\evar), (WF), PrSt2)
      /\ {PrSt4, SubId} := substitutionLemma(PId, PId, FVId, XId, PrSt3)
      /\ {PrSt5, ClaimId} := appendProofStep(WfId, (ExistsQ SubId), PrSt4) .

     eq applyCommand(eq Q:Qid P, ProofState) =
        'Existential 'quantification 'failed '\n
        'Check 'if Q:Qid 'occurs 'free 'in 'pattern
        [owise] .

    *** ∃-Generalization Inference Rule
    ceq applyCommand(eg Q:Qid Ant Con, ProofState) =
        appendAntecedent(0, WfId,
          (exists EVar . Ant') --> Con', PrSt2)
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' := amlPatternMatch(Ant --> Con, upTerm(AM),
              'false.Bool := 'isFreeIn[('evar[upTerm(Q:Qid)]), upTerm(Ant)])
      /\ EVar := evar(Q:Qid)
      /\ AM1 ; [- N (WfI): Ant' --> Con' ] ; AM2 |- CM
          := getGoal(0, ProofState)
      /\ {PrSt1 ^ hilbertProof(Proof), WfId} :=
          wfPatternLemma((exists EVar . Ant') --> Con', ProofState)
      /\ XId := (getVariableIndex(PrSt1)[EVar])
      /\ ClaimId := getClaimId((WfI), Proof)
      /\ (\imp PId QId) := Proof[WfI]
      /\ {Proof', NFId} := notFreeLemma(XId, QId, Proof)
      /\ {PrSt2, Id} :=
          appendProofStep(WfId,
              (ExistsR ClaimId NFId),
              PrSt1 ^ hilbertProof(Proof')) .

    eq applyCommand(eg Q:Qid Ant Con, ProofState) =
        'Existential 'Generalization 'failed [owise] .

    *** Propagation-_|_
    eq applyCommand(lbp P, ProofState) =
        axiomIntroRule(0, bot @ P --> bot, (PropagationBotL), ProofState) .

    eq applyCommand(rbp P, ProofState) =
        axiomIntroRule(0, P @ bot --> bot, (PropagationBotR), ProofState) .

    *** Propagation-\/
    eq applyCommand(lop C:Pattern P Q, ProofState) =
        axiomIntroRule(0,
          (P \/ Q) @ C:Pattern --> ((P @ C:Pattern) \/ (Q @ C:Pattern)),
          (PropagationOrL), ProofState) .

    eq applyCommand(rop C:Pattern P Q, ProofState) =
        axiomIntroRule(0,
           C:Pattern @ (P \/ Q) --> ((C:Pattern @ P) \/ (C:Pattern @ Q)),
          (PropagationOrR), ProofState) .

    *** Propagation-∃
    ceq applyCommand(lep C:Pattern EVar P, ProofState) =
        axiomIntroRule(0,
          (exists EVar . P) @ C:Pattern --> (exists EVar . P @ C:Pattern),
          (PropagationExL NFId), ProofState')
      if {ProofState', NFId} := notFreeLemma(EVar, C:Pattern, ProofState) .

    ceq applyCommand(rep C:Pattern EVar P, ProofState) =
        axiomIntroRule(0,
          C:Pattern @ (exists EVar . P) --> (exists EVar . C:Pattern @ P),
          (PropagationExR NFId), ProofState')
      if {ProofState', NFId} := notFreeLemma(EVar, C:Pattern, ProofState) .

    *** Framing
    ceq applyCommand(lfr C:Pattern Ant Con, ProofState) =
        axiomIntroRule(0, Ant' @ C:Pattern --> Con' @ C:Pattern, (FrameL ClaimId),
          ProofState)
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' := amlPatternMatch(Ant --> Con, upTerm(AM))
      /\ AM1 ; [- N (WfI): Ant' --> Con'] ; AM2 := AM
      /\ ClaimId := getClaimId((WfI), getProof(ProofState)) .

    ceq applyCommand(rfr C:Pattern Ant Con, ProofState) =
        axiomIntroRule(0, C:Pattern @ Ant' --> C:Pattern @ Con', (FrameR ClaimId),
          ProofState)
      if AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' := amlPatternMatch(Ant --> Con, upTerm(AM))
      /\ AM1 ; [- N (WfI): Ant' --> Con'] ; AM2 := AM
      /\ ClaimId := getClaimId((WfI), getProof(ProofState)) .

    *** set variable substitution
    ceq applyCommand(svs X:Qid Hyp Q, ProofState) =
        appendAntecedent(0, WfId, Conclusion, PrSt5)
      if SVar := svar(X:Qid)
      /\ AM |- CM := getGoal(0, ProofState)
      /\ Hyp' := amlPatternMatch(Hyp, upTerm(AM), upTerm(Hyp[Q / SVar]) : 'Pattern)
      /\ AM1 ; [- N (WfI): Hyp'] ; AM2 := AM
      /\ {PrSt1, XId} := wfPatternLemma(SVar,ProofState)
      /\ {PrSt2, QId} := wfPatternLemma(Q, PrSt1)
      /\ Conclusion := Hyp'[Q / SVar]
      /\ {PrSt3, WfId} := wfPatternLemma(Conclusion, PrSt2)
      /\ {PrSt4, SubId} := substitutionLemma(WfId, (WfI), QId, XId, PrSt3)
      /\ ClaimId := getClaimId((WfI), getProof(PrSt4))
      /\ {PrSt5, Id} :=
          appendProofStep(WfId, (SVarSubst (ClaimId) SubId), PrSt4) .

    eq applyCommand(svs X:Qid Hyp Q, ProofState) =
        'Set 'Variable 'Substitution 'failed '\n
        'Check 'that 'substitution 'avoids 'alpha 'capture
        [owise] .

    *** Pre-Fixpoint
    ceq applyCommand(pfp X:Qid P, ProofState) =
        appendAntecedent(0, WfId, R --> Q, PrSt5)
      if SVar := svar(X:Qid)
      /\ Q := mu SVar . P
      /\ R := P[mu SVar . P / SVar]
      /\ {PrSt, PId} := wfPatternLemma(P, ProofState)
      /\ {PrSt1, QId} := wfPatternLemma(Q, PrSt)
      /\ {PrSt2, RId} := wfPatternLemma(R, PrSt1)
      /\ XId := (getVariableIndex(PrSt2)[SVar])
      /\ {PrSt3, SubId} := substitutionLemma(RId, PId, QId, XId, PrSt2)
      /\ {PrSt4, WfId} := wfPatternLemma(R --> Q, PrSt3)
      /\ {PrSt5, ClaimId} := appendProofStep(WfId, (Prefixpoint SubId), PrSt4) .

    eq applyCommand(pfp X:Qid P, ProofState) =
        'Pre-fixpoint 'failed '\n
        'Check 'that 'substitution 'avoids 'alpha 'capture
        [owise] .

    *** Knaster-Tarski
    ceq applyCommand(kt X:Qid P Con, ProofState) =
        appendAntecedent(0, WfId, Conclusion, PrSt3)
      if SVar := svar(X:Qid)
      /\ AM |- CM := getGoal(0, ProofState)
      /\ Ant' --> Con' :=
          amlPatternMatch(
              '_-->_['Ant:Pattern, upTerm(Con)],
              upTerm(AM),
              'Ant:Pattern := upTerm(P[Con / SVar]))
      /\ AM1 ; [- N (WfI): Ant' --> Con'] ; AM2 := AM
      /\ ClaimId := getClaimId((WfI), getProof(ProofState))
      /\ (\imp RId QId) := getProof(ProofState)[((WfI)).Id]
      /\ Conclusion := (mu SVar . P) --> Con'
      /\ {PrSt1, WfId} := wfPatternLemma(Conclusion, ProofState)
      /\ (\imp Id QId) := getProof(PrSt1)[WfId]
      /\ (\mu XId PId) := getProof(PrSt1)[Id]
      /\ {PrSt2, SubId} := substitutionLemma(RId, PId, QId, XId, PrSt1)
      /\ {PrSt3, (I)} := appendProofStep((WfId), (KT ClaimId SubId), PrSt2) .

    eq applyCommand(kt X:Qid PreP Q, ProofState) =
        'Knaster-Tarksi 'failed '\n
        'check 'that 'pattern 'argument 'is  'correct 'substitution
        [owise] .

    *** Existence Axiom
    eq applyCommand(ex Q:Qid, ProofState) =
        axiomIntroRule(0, exists evar(Q:Qid) . evar(Q:Qid), (Existence),
          ProofState) .

    *** Singleton Axiom
    *** let Q := x /\ P    == (x -> (P -> _|_)) -> _|_
    ***     R := x /\ ~ P  == (x -> P) -> _|_
    *** C1[Q] -> (C2[R] -> bot)
    ceq applyCommand(sng Ctx1 Ctx2 Q:Qid P, ProofState) =
        appendAntecedent(0, WfId, (Ctx1[Q]) --> (Ctx2[R]) --> bot, PrSt11)
      if EVar := evar(Q:Qid)
      /\ Q := ~ (EVar --> ~ P)
      /\ R := ~ (EVar -->   P)
      /\ {PrSt, QId} := wfPatternLemma(Q, ProofState)
      /\ {PrSt1, RId} := wfPatternLemma(R, PrSt)
      /\ {PrSt2, FVId} := appendProofStep((\evar), (WF), PrSt1)
      /\ {PrSt3, ACId1} := applicationContextLemma(FVId, Ctx1, PrSt2)
      /\ {PrSt4, ACId2} := applicationContextLemma(FVId, Ctx2, PrSt3)
      /\ (#appctx CId1 FVId) := getProof(PrSt4)[ACId1]
      /\ (#appctx CId2 FVId) := getProof(PrSt4)[ACId2]
      /\ {PrSt5, ResId1} := wfSubstitutionLemma(CId1, QId, FVId, PrSt4)
      /\ {PrSt6, ResId2} := wfSubstitutionLemma(CId2, RId, FVId, PrSt5)
      /\ {PrSt7, SubId1} := substitutionLemma(ResId1, CId1, QId, FVId, PrSt6)
      /\ {PrSt8, SubId2} := substitutionLemma(ResId2, CId2, RId, FVId, PrSt7)
      /\ {PrSt9, Id} := appendProofStep((\imp ResId2 (0)), (WF), PrSt8)
      /\ {PrSt10, WfId} := appendProofStep((\imp ResId1 Id), (WF), PrSt9)
      /\ {PrSt11, ClaimId} :=
        appendProofStep(WfId, (Singleton ACId1 SubId1 ACId2 SubId2), PrSt10) .

    eq applyCommand(sng Ctx1 Ctx2 Q:Qid P, ProofState) =
        'Singleton 'command 'failed [owise] .

***************************
*** Derived Proof Rules ***
***************************

    *** PropI
    ceq applyCommand(I P, ProofState) =
      appendAntecedent(0, WfId, P --> P, ProofState' ^ hilbertProof(Proof Proof'))
      if {ProofState' ^ hilbertProof(Proof), Id} :=
              wfPatternLemma(P, ProofState)
      /\ {Proof', WfId} := propILemma(s getStepNum(Proof), Id) .

******************************
*** Sequent Calculus Rules ***
******************************

    *** ASSERT
    ceq applyCommand(assert, ProofState ^ goals(GM)) =
        ProofState ^
        goals(
          GM1 ;
          [GIndex (GI):
            proved(P, (WfI), getClaimId((WfI), getProof(ProofState)))
          ] ;
          GM2
        )
      if GM1 ;
         [GIndex (GI):
            AM1 ; [- N (WfI): P] ; AM2 |-
            CM1 ; [  M (I2):  P] ; CM2
         ] ;
         GM2 := GM .

    eq applyCommand(assert, ProofState) =
        'No 'match 'for 'ASSERT 'judgement [owise] .

*** Catchall
    ceq applyCommand(CMD:ProverCMD, ProofState) =
        'Command Op:Qid 'not 'implemented 'yet
      if Op:Qid [ Args:TermList ] := upTerm(CMD:ProverCMD) [owise] .

************************
*** Helper Functions ***
************************

    *** Introduce Axiom with no side conditions
    op axiomIntroRule : Nat Pattern AMLRule ProofState ~> ProofState .
    ceq axiomIntroRule(GIndex, Axiom, Rule, ProofState)  =
        appendAntecedent(GIndex, WfId, Axiom, PrSt2)
      if {PrSt, WfId} := wfPatternLemma(Axiom, ProofState)
      /\ {PrSt2, ClaimId} := appendProofStep(WfId, Rule, PrSt) .

    op amlPatternMatch : Pattern Term           ~> Pattern .
    op amlPatternMatch : Pattern Term Condition ~> Pattern .
    op amlPatternMatch : Term    Term Condition ~> Pattern .
    eq amlPatternMatch(P, Term) = amlPatternMatch(P, Term, nil) .
    eq amlPatternMatch(P, Term, Condition) =
        amlPatternMatch(upTerm(P), Term, Condition) .
    ceq amlPatternMatch(Term1, Term2, Condition) =
        downTerm(applySubstitution(Term1, Sub), bot)
      if Sub := getSubstitution(
            metaXmatch(['PRINT-AML-GOAL], Term1, Term2,
              Condition, 0, unbounded, 0)) .

    *** Print Current Goal after successful rule application
    op printSuccess : ProofState -> QidList .
    eq printSuccess(goals([0 (I:Nat): G] ; GM) ^ hilbertProof(Proof) ^ S) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G))
      if check(Proof)
        then nil
        else '\n 'Proof 'has 'become 'invalid. '\n
             'this 'is 'a 'bug.
      fi .

    vars N M I I2 WfI HypWfI AntWfI GIndex GI GI1 GI2 : Nat .
    vars Id PId QId RId XId FVId WfId CId1 CId2 ResId1 ResId2 : Id .
    vars NFId ACId1 ACId2 SubId SubId1 SubId2
    vars ClaimId AntClaimId HypClaimId : Id .
    var SVar : SVar .
    var EVar : EVar .
    vars P Q R Ant Ant' Con Con' Hyp Hyp' Conclusion PreP Axiom : Pattern .
    vars Ctx Ctx1 Ctx2 : ApplicationContext .
    var Hypotheses : PatternList .
    vars AM AM1 AM2 AM3 : AntecedentMap .
    vars CM CM1 CM2 : ConsequentMap .
    vars G G' : Goal .
    vars GM GM1 GM2 : GoalMap .
    var Rule : AMLRule .
    vars Proof Proof' CommentedProof : CommentedProof .
    vars S ProofState ProofState' PrState : ProofState .
    vars PrSt PrSt1 PrSt2 PrSt3 PrSt4 PrSt5 : ProofState .
    vars PrSt6 PrSt7 PrSt8 PrSt9 PrSt10 PrSt11 : ProofState .
    var Label : Qid .
    vars ProofStateTerm Term Term1 Term2 : Term .
    vars Sub Sub' : Substitution .
    var Condition : Condition .
endm

mod AML-PROVER is
    pr AML-PROVER-COMMANDS .
    including LOOP-MODE * (op [_,_,_] to [_#_#_] ) .

    subsort ProofState < State .

    op init : -> System .
    eq init = [nil # .ProofState # 'AML 'THEOREM 'PROVER] .

    *** Loop mode IO rules
    crl [inputCorrectCMDSucceeds] :
        [ QIN # S # QOUT ] => [ nil # S' # QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ [S' # QOUT'] := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDSucceeds] :
        [ QIN # S # QOUT ] => [ nil # S' # printSuccess(S') ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ S' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDOutput] :
        [ QIN # S # QOUT ] => [ nil # S # QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ QOUT' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDMalformed] :
        [QIN # S # QOUT ] => [ nil # S #
          'Command 'is 'malformed '\n
          'Check 'that 'pattern 'arguments 'are 'well-formed ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ not (downTerm(Term, noop) :: ProverCMD) .

    crl [inputCorrectCMDFails] :
        [QIN # S # QOUT ] => [ nil # S # 'Command 'application 'failed ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ not (applyCommand(downTerm(Term, noop), S) :: CommandResult) .

    crl [inputAmbiguous] :
        [ QIN # S # QOUT ] => [ Term # S #
          'Ambiguous 'parse. 'Choosing 'first: '\n
          Term '\n ]
      if QIN =/= nil
      /\ ambiguity({Term, Type}, T) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    crl [emptyProofState] :
        [ QIN # S # QOUT ] => [nil # S #
          'ERROR: 'There 'is 'no 'proof 'in 'progress '\n
          'try 'begin 'proof 'of 'PATTERN'
          ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ noProof := applyCommand(downTerm(Term, noop), S) .

    crl [inputFail] :
        [ QIN # S # QOUT ] => [ nil # S #
          'ERROR 'on 'input: QIN '\n
          'Parsing 'failed 'at 'column pretty(N:Nat)
          ]
      if QIN =/= nil
      /\ noParse(N:Nat) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    op rewriteProofState : ProofState -> ProofState .
    eq rewriteProofState(ProofState) =
        rewriteProofState(ProofState, unbounded) .
    op rewriteProofState : ProofState Bound -> ProofState .
    ceq rewriteProofState(ProofState, B:Bound) = downTerm(Term, .ProofState)
      if {Term, Type} := metaRewrite(['AML-PROVER], upTerm(ProofState), B:Bound) .

    vars QIN QOUT QOUT' QOUT'' : QidList .
    vars S S' ProofState : ProofState .
    var Term : Term .
    var Type : Type .
    var T : ResultPair? .
endm
