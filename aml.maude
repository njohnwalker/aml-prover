**********************************
*** Applicative Matching Logic ***
*** Interactive Theorem Prover ***
**********************************

in checker/checker/maude/checker.maude

fmod AML-CHECKER is
    extending CHECKER * (sort Rule to AMLRule, op ___;_ to ___;;_ ) .
    *** avoid applying the equation that erases comments for ease of use
    *** mimmic the operator syntax so printed output can be read by the checker
    sort CommentedProofStep CommentedProof .
    subsort ProofStep < Proof CommentedProofStep < CommentedProof .
    op __ : CommentedProof CommentedProof -> CommentedProof [ctor ditto] .
    op __ : CommentedProof Proof -> CommentedProof [ctor ditto] .
    op __ : Proof CommentedProof -> CommentedProof [ctor ditto] .
    op ___;_ : Id Claim AMLRule String -> CommentedProofStep [ctor] .

    *** Explicitly convert back to the original proof constructor
    op stripComments : CommentedProof -> Proof .
    eq stripComments(Pi1 Id C Rl ; S Pi2) =
        stripComments(Pi1 Id C Rl ;; S Pi2 ) .
    eq stripComments(Pi1) = Pi1 [owise] .

    *** Helpers
    ops check check-id check-step : CommentedProof -> Bool .
    eq check(Proof) = check(stripComments(Proof)) .
    eq check-id(Proof) = check-id(stripComments(Proof)) .
    eq check-step(Proof) = check-step(stripComments(Proof)) .

    op getStepNum : CommentedProof -> Nat .
    eq getStepNum(.Proof) = 0 .
    eq getStepNum(Pi1 (N) C Rl ;) = N .
    eq getStepNum(Pi1 (N) C Rl ; S) = N .

    op getClaimId : CommentedProof Id -> Id .
    ceq getClaimId(Proof, Id) = Id'
      if (Pi1 PrStep Pi2) := Proof
      /\ Id' Id Rl ; := stripComments(PrStep) .

    vars N M : Nat .
    vars Id Id' : Id .
    var C : Claim . var Rl : AMLRule . var S : String .
    vars Pi1 Pi2 Proof : CommentedProof .
    var PrStep : ProofStep .
endfm

******************************
*** AML Syntax Definitions ***
******************************
fmod VARIABLES is
    protecting AML-CHECKER .
    protecting QID .
    sorts EVar SVar Var .
    subsort EVar SVar < Var .
    op evar : Qid -> EVar [ctor] .
    op svar : Qid -> SVar [ctor] .

    op getVarName : Var -> Qid .
    eq getVarName(evar(Q)) = Q .
    eq getVarName(svar(Q)) = Q .

    op getVarType : Var -> Claim .
    eq getVarType(EV) = (\evar) .
    eq getVarType(SV) = (\svar) .

    var Q : Qid . var EV : EVar . var SV : SVar .
endfm

fmod AML-CORE is protecting VARIABLES .
    protecting EXT-BOOL .
*** terse AML Patterns

    sorts Symbol Pattern .
    subsort Var Symbol < Pattern .

    *** Pattern Application
    op _@_  : Pattern Pattern -> Pattern [ctor gather (E e) format (d s ++s --)] .

    *** Patten Implication
    op _-->_  : Pattern Pattern -> Pattern [ctor format (d s s++ --)] .

    *** Bottom
    op bot : -> Pattern [ctor] .

    *** Universal quantification
    op exists_._ : EVar Pattern -> Pattern [ctor format (d s s s++ --)] .

    *** least fixpoint
    op mu_._ : SVar Pattern ~> Pattern [ctor format (d s s s++ --)] .
    *** condition on set variable fixpoints
    cmb mu X . P : Pattern if positive(X,P) .

    var B : Bool . vars X X' : SVar . vars P Q : Pattern .  var S : Symbol .
    op positive : SVar Pattern -> Bool .
    eq positive(X,P) = $positive(true, X, P) .

    op $positive : Bool SVar Pattern -> Bool .
    eq $positive(B, X, bot) = true .
    eq $positive(B, X, S) = true .
    eq $positive(B, X, X) = B .
    eq $positive(B, X, X') = true .
    eq $positive(B, X, P @ Q) = $positive(B, X, P) and-then $positive(B, X, Q) .
    eq $positive(B, X, P --> Q) = $positive(not B, X, P) and-then $positive(B, X, Q) .
    eq $positive(B, X, exists (x:EVar) . P) = $positive(B, X, P) .
    eq $positive(B, X, mu X . P) = true .
    eq $positive(B, X, mu X' . P) = $positive(B, X, P) .
endfm

view Pattern from TRIV to AML-CORE is sort Elt to Pattern . endv
view Symbol  from TRIV to AML-CORE is sort Elt to Symbol  . endv
view Var     from TRIV to AML-CORE is sort Elt to Var     . endv

fmod PATTERN-SET is
    inc SET{Pattern} *
        ( sort NeSet{Pattern} to NePatternSet
        , sort Set{Pattern} to PatternSet
        ) .
endfm

fmod PATTERN-LIST is
    inc LIST{Pattern} *
        ( sort NeList{Pattern} to NePatternList
        , sort List{Pattern} to PatternList
        ) .
endfm

fmod AML is including AML-CORE .
    protecting PATTERN-SET .
*** Add syntactic sugar and variable substitution
*** to AML core representation

    vars P Q P' P'' : Pattern .
    var x : EVar .
    vars X X' : SVar .
    var S : Symbol .
    vars V V' : Var .

    *** Top
    op top : -> Pattern .
    eq top = exists evar('x) . evar('x) .

    *** Not
    op ~_ : Pattern -> Pattern .
    eq ~ P = P --> bot .

    *** Or, And
    ops _\/_ _/\_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P \/ Q = (~ P) --> Q .
    eq P /\ Q = ~((~ P) \/ (~ Q)) .


    *** If-and-only-if
    op _<-->_ : Pattern Pattern -> Pattern [assoc comm] .
    eq P <--> Q = (P --> Q) /\ (Q --> P) .

    *** Quantifiers
    op forall_._ : EVar Pattern -> Pattern .
    eq forall x . P = ~ (exists x . ~ P ) .

    *** greatest fixpoint
    op nu_._ : EVar Pattern ~> Pattern .
    eq nu X . P = ~ (mu X . ~ (P[~ X / X])) .

    ********************
    *** Substitution ***
    op _[_/_] : Pattern Pattern Var ~> Pattern .

    *** Alpha capture substitution side-condition
    op alphaCapture : -> [Pattern] .
    ceq P [Psub / V] = alphaCapture if alphaCaptures(V, P, Psub) .

    eq bot[Psub / V] = bot .
    eq S[Psub / V] = S .
    eq V[Psub / V] = Psub .
    eq V'[Psub / V] = V' .

    eq (P @ P')[Psub / V] = (P[Psub / V]) @ (P'[Psub / V]) .

    eq (P --> P')[Psub / V] = P[Psub / V] --> (P'[Psub / V]) .

    eq (exists V . P)[Psub / V] = exists V . P .
    eq (exists V' . P)[Psub / V] = exists V' . (P[Psub  / V]) .

    eq (mu V . P)[Psub / V] = mu V . P .
    eq (mu V' . P)[Psub / V] = mu V' . (P[Psub  / V]) .

    op isFreeIn : Var Pattern -> Bool .
    eq isFreeIn(V, bot) = false .
    eq isFreeIn(V, V) = true .
    eq isFreeIn(V, V') = false .
    eq isFreeIn(V, S) = false .
    eq isFreeIn(V, P @ P') = isFreeIn(V, P) or-else isFreeIn(V, P') .
    eq isFreeIn(V, P --> P') = isFreeIn(V, P) or-else isFreeIn(V, P') .
    eq isFreeIn(V, exists V . P) = false .
    eq isFreeIn(V, exists V' . P) = isFreeIn(V, P) .
    eq isFreeIn(V, mu V . P) = false .
    eq isFreeIn(V, mu V' . P) = isFreeIn(V, P) .

    var B : Bool .
    var Psub : Pattern .
    var Vb : Var .
    op alphaCaptures : Var Pattern Pattern -> Bool .
    eq alphaCaptures(V, P, Psub) = $alphaCaptures(false, V, P, Psub) .

    op $alphaCaptures : Bool Var Pattern Pattern -> Bool .
    eq $alphaCaptures(B, Vb, Vb, Psub) = B .

    eq $alphaCaptures(B, Vb, bot, Psub) = false .

    eq $alphaCaptures(B, Vb, V', Psub) = false .

    eq $alphaCaptures(B, Vb, S, Psub) = false .

    eq $alphaCaptures(B, Vb, P @ P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, P --> P', Psub) =
        $alphaCaptures(B, Vb, P, Psub) and-then $alphaCaptures(B, Vb, P', Psub) .

    eq $alphaCaptures(B, Vb, exists Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, exists V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .

    eq $alphaCaptures(B, Vb, mu Vb . P, Psub) = false .
    eq $alphaCaptures(B, Vb, mu V' . P, Psub) =
        $alphaCaptures(B or-else isFreeIn(V', Psub), Vb, P, Psub) .

    var PS : PatternSet .
    op getSymbols : PatternSet -> PatternSet .
    eq getSymbols(S) = S .
    eq getSymbols(bot) = empty .
    eq getSymbols(V) = empty .
    eq getSymbols(P @ P') = getSymbols(P) , getSymbols(P') .
    eq getSymbols(P --> P') = getSymbols(P) , getSymbols(P') .
    eq getSymbols(exists V . P) = getSymbols(P) .
    eq getSymbols(mu V . P) = getSymbols(P) .
    eq getSymbols((P, PS)) = getSymbols(P) , getSymbols(PS) .

    op getVars : PatternSet -> PatternSet .
    eq getVars(V) = V .
    eq getVars(bot) = empty .
    eq getVars(S) = empty .
    eq getVars(P @ P') = getVars(P) , getVars(P') .
    eq getVars(P --> P') = getVars(P) , getVars(P') .
    eq getVars(exists V . P) = getVars(P) .
    eq getVars(mu V . P) = getVars(P) .
    eq getVars((P, PS)) = getVars(P) , getVars(PS) .
endfm

***********************
*** PRETTY PRINTING ***
***********************
fmod META-LEVEL' is pr META-LEVEL * ( op _`,_ to _~_ ) .
endfm

fmod PRETTY is pr AML .
    pr META-LEVEL' .

    *** Natural Numbers
    vars N : Nat .
    op pretty : Nat -> QidList .
    eq pretty(N:Nat) = metaPrettyPrint(['NAT], upTerm(N:Nat)) .

    op prettyString : Nat -> String .
    eq prettyString(N) = string(pretty(N)) .

    *** Patterns
    var P : Pattern .
    op pretty : Pattern -> QidList .
    eq pretty(P) = metaPrettyPrint(['AML-USER-THEORY], upTerm(P)) .

endfm

in aml-user-theory.maude

**********************
*** Prover Modules ***
**********************
mod AML-GOAL is including AML .
    pr PRETTY .
    pr PATTERN-LIST .
    sorts ConsequentMap AntecedentMap .

    op mt : -> AntecedentMap [ctor] .
    op mt : -> ConsequentMap [ctor] .
    op [-_`(_`):_] : Nat Nat Pattern -> AntecedentMap [ctor format (d s d s d d d n++i -- d) ] .
    op  [_`(_`):_] : Nat Nat Pattern -> ConsequentMap [ctor format (d sss s d d d n++i -- d) ] .
    op _;_ : AntecedentMap AntecedentMap -> AntecedentMap [ctor assoc id: mt format (d s n d) ] .
    op _;_ : ConsequentMap ConsequentMap -> ConsequentMap [ctor assoc id: mt format (d s n d) ] .

    sort Goal .
    op _|-_ : AntecedentMap ConsequentMap -> Goal [ctor prec 100 format (d nt n d)] .
    op _proved`at_ : Pattern Id -> Goal [ctor] .

    sort GoalMap .
    op mt : -> GoalMap [ctor] .
    op [_`(_`):_] : Nat Nat Goal -> GoalMap [ctor] .
    op _;_ : GoalMap GoalMap -> GoalMap [ctor assoc id: mt] .

*** Antecedent Map Invariant
*** requires: exists a (-1) indexed element in the map
    crl [antecedentMapInvariant] :
        [- N (I): P] ; [- M (I'): P'] => [- s M (I): P] ; [- M (I'): P']
      if N == M or N > s M .

*** Consequent and Goal Map invariants
*** requires: exists a 0 indexed element in the map
    crl [consequentMapInvariant] :
        [N (I): P] ; [M (I'): P'] => [N (I): P] ; [s N (I'): P']
      if M == N or M > s N .

    crl [goalMapInvariant] :
        [N (I): G] ; [M (I'): G'] => [N (I): G] ; [s N (I'): G']
      if M == N or M > s N .

    *** Construct a AntecedentMap from a set of Patterns
    op makeClaim : PatternList Pattern -> Pattern .
    eq makeClaim(nil, Conclusion) = Conclusion .
    eq makeClaim(P PL, Conclusion) = P --> makeClaim(PL, Conclusion) .

    *** Print a GoalMap
    op pretty : GoalMap -> QidList .
    eq pretty([N (I): AM |- [0 (I): P]; CM] ; GM) =
        pretty(N) ': '... '|- pretty(P) '\n
        pretty(GM) .
    eq pretty(mt) = nil .

    op fresh : AntecedentMap -> Nat .
    eq fresh((mt).AntecedentMap) = 1 .
    eq fresh([- N (I): P] ; AM) = s N .

    op fresh : ConsequentMap -> Nat .
    eq fresh((mt).ConsequentMap) = 0 .
    eq fresh(CM ; [N (I): P]) = N .

    var AM : AntecedentMap . var CM : ConsequentMap . var GM : GoalMap .
    vars N M I I' : Nat .
    vars P P' Conclusion : Pattern .
    var PL : PatternList .
    vars G G' : Goal .
endm

*** Module to metaPrettyPrint all user space AML symbols and Proof goals
*** useful for more efficient meta-representation of module to print in
mod PRINT-AML-GOAL is protecting AML-GOAL + AML-USER-THEORY . endm

mod AML-PROOF-STATE is
    pr AML-GOAL . inc AML-CHECKER .
    pr PRINT-AML-GOAL .

    pr PATTERN-SET .
    pr MAP{Symbol, Nat} * ( op undefined to undefinedSym, op _|->_ to _|-S>_ ) .
    pr MAP{Var, Nat} * ( op undefined to undefinedVar, op _|->_ to _|-V>_ ) .

    sort ProofState .
    op .ProofState : -> ProofState [ctor] .
    op _^_ : ProofState ProofState -> ProofState [assoc comm ctor format (d ni s d)] .

    ops goalCounter : Nat -> ProofState [ctor] .
    op goals : GoalMap -> ProofState [ctor format (++ --)] .

    op symbolIndex : Map{Symbol,Nat} -> ProofState [ctor] .

    op variableIndex : Map{Var,Nat} -> ProofState [ctor] .

    *** intermediate proof objects
    op hilbertProof : CommentedProof -> ProofState [ctor] .
    op tacticProof : -> ProofState [ctor] . *** TODO

    *** Projections
    op getProof : ProofState -> CommentedProof .
    eq getProof(hilbertProof(Proof) ^ ProofState) = Proof .
    eq getProof(ProofState) = .Proof [owise] .

    var Proof : CommentedProof .
    var ProofState : ProofState .
endm

*** Useful sub-proofs for AML proofs
mod AML-PROOF-LEMMAS is
    pr AML-PROOF-STATE .

    sort ProofAndIndex .
    op {_,_} : CommentedProof Id -> ProofAndIndex .

    *** Identity Implication Tautology (P -> P)
    op propILemma : Nat Id -> ProofAndIndex .
    eq propILemma(N, PatWFId) =
        { (     N) (\imp PatWFId PatWFId)  (WF) ; "begin propILemma"
                                                  ***| P -> P
          (1  + N) (\imp PatWFId (N))      (WF) ; ***| P -> (P -> P)
          (2  + N) (1 + N)              (PropK) ; ***| PropK P P
          (3  + N) (\imp (N) PatWFId)      (WF) ; ***| (P -> P) -> P
          (4  + N) (\imp PatWFId (3 + N))  (WF) ; ***| P -> ((P -> P) -> P)
          (5  + N) (4 + N)              (PropK) ; ***| PropK P (P -> P)
          (6  + N) (\imp (1 + N) (N))      (WF) ; ***| (P -> (P -> P)) -> (P -> P)
          (7  + N) (\imp (4 + N) (6 + N))  (WF) ; ***| (P -> ((P -> P) -> P))
                                                  ***  -> ((P -> (P -> P)) -> (P -> P))
          (8  + N) (7 + N)              (PropS) ; ***| PropS P (P -> P) P
          (9  + N) (6 + N) (MP (5 + N) (8 + N)) ; ***| MP 5 8
          (10 + N) (    N) (MP (2 + N) (9 + N)) ; ***| MP 2 9
                                                  "end propILemma"
          , (N) }
        .

    sort ProofStateAndIndex .
    op {_,_} : ProofState Id -> ProofStateAndIndex .

    op  wfPatternLemma : Pattern ProofState -> ProofStateAndIndex .
    eq  wfPatternLemma(bot, PrSt) = {PrSt, (0)} .

    ceq wfPatternLemma(V, variableIndex(VM) ^ PrSt) =
        {variableIndex(VM) ^ PrSt, (M)}
      if M := VM[V] .

    ceq wfPatternLemma(V, variableIndex(VM) ^ hilbertProof(Proof) ^ PrSt) =
        { variableIndex((VM, V |-V> N)) ^
            hilbertProof(Proof (N) getVarType(V) (WF) ; string(getVarName(V))) ^
            PrSt
            , (N) }
      if undefinedVar := VM[V] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ PrSt)  =
        {symbolIndex(SM) ^ PrSt, (M)}
      if M := SM[S] .

    ceq wfPatternLemma(S, symbolIndex(SM) ^ hilbertProof(Proof) ^ PrSt) =
        { symbolIndex((SM, S |-S> N)) ^
            hilbertProof(Proof (N) (\symb) (WF) ; string(pretty(S))) ^
            PrSt
            , (N) }
      if undefinedSym := SM[S] /\ N := s getStepNum(Proof) .

    ceq wfPatternLemma(exists EV . P, PrSt) =
        { PrSt'' ^ hilbertProof(Proof'' (N'') (\ex Id1 Id2) (WF) ;) , (N') }
      if {PrSt', Id1} := wfPatternLemma(EV, PrSt)
      /\ N' := s getStepNum(getProof(PrSt'))
      /\ {PrSt'' ^ hilbertProof(Proof''), Id2} := wfPatternLemma(P, PrSt')
      /\ N'' := s getStepNum(Proof'') .

    ceq wfPatternLemma(mu SV . P, PrSt) =
        { PrSt''' ^
          hilbertProof(Proof' (N') (\mu Id1 Id3) (WFMu Id2) ; ),
          (N')
        }
      if {PrSt', Id1} := wfPatternLemma(SV, PrSt)
      /\ {PrSt'', Id2} := nonNegativeLemma(SV, P, PrSt')
      /\ {PrSt''' ^ hilbertProof(Proof'), Id3} := wfPatternLemma(P, PrSt'')
      /\ N' := s getStepNum(Proof') .

    ceq wfPatternLemma(P @ P', PrSt) =
        { PrSt'' ^
          hilbertProof(Proof' (N') (\app Id1 Id2) (WF) ; ),
          (N')
        }
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt'' ^ hilbertProof(Proof'), Id2} := wfPatternLemma(P', PrSt')
      /\ N' := s getStepNum(Proof') .

    ceq wfPatternLemma(P --> P', PrSt) =
        { PrSt'' ^
          hilbertProof(Proof' (N') (\imp Id1 Id2) (WF) ; ),
          (N')
        }
      if {PrSt', Id1} := wfPatternLemma(P, PrSt)
      /\ {PrSt'' ^ hilbertProof(Proof'), Id2} := wfPatternLemma(P', PrSt')
      /\ N' := s getStepNum(Proof') .

    op nonNegativeLemma : SVar Pattern ProofState -> ProofStateAndIndex .

    vars N N' N'' N''' M M' : Nat . vars Id Id1 Id2 Id3 PatWFId : Id .
    var S : Symbol . vars P P' : Pattern .
    var V : Var . var EV : EVar . var SV : SVar .
    vars Proof Proof' Proof'' : CommentedProof .
    vars SM SM' : Map{Symbol,Nat} . vars VM VM' : Map{Var,Nat} .
    vars PrSt PrSt' PrSt'' PrSt''' : ProofState .
endm

mod AML-PROOF-STATE-TRANSITIONS is
    inc AML-PROOF-STATE .
    inc AML-PROOF-LEMMAS .

    op initializeProofState : PatternList Pattern -> ProofState .
    eq initializeProofState(Assumptions, Conclusion) =
        tacticProof
        ^ hilbertProof((0) (\bot) (WF) ;)
        ^ goalCounter(1)
        ^ symbolIndex(empty)
        ^ variableIndex(empty)
        ^ goals(
          [ 0 (0):
            mt |- [ 0 (0): makeClaim(Assumptions,Conclusion) ]
            ]
          )
        .

    *** GoalMap precondition
    crl [gmPre] : goals([N (I): G] ; GM ) => goals([0 (I): G] ; GM) if N > 0 .

    vars N I : Nat .
    var Conclusion : Pattern . var Assumptions : PatternList .
    var G : Goal . var GM : GoalMap .
endm

mod AML-JUDGEMENTS is including AML-PROOF-STATE-TRANSITIONS .
***(
The rewrite rules in this module define the proof rules,
judgments, and tactics for interactive AML Proofs
Every rule should be labelled and marked `nonexec`
since they will be `metaApply`ed by the applyCommand
equation to enable pattern matching and substitution
preprocessing as well as descriptive error messages .
)
*** axiom rule states `Gamma,Ax |- Ax,Consequents`
*** and generates the converted hilbert proof
    rl [axiom] :
        hilbertProof(Proof) ^
        goals([GIndex (I): AM1 ; [- N (WfI): P] ; AM2 |- CM1 ; [M (I2): P] ; CM2] ; GM)
      =>
        hilbertProof(Proof) ^
        goals([GIndex (I): P proved at (WfI) ] ; GM)
        [nonexec] .

*** identity rule states `|- P --> P` forall well-formed P
*** RHS Free Variables:
*** - `IdPattern` instantiating Pattern
    crl [identity] :
        ProofState
      =>
        ProofState' ^
        hilbertProof(Proof' Proof'') ^
        goals([GIndex (N): [- fresh(AM) (I): IdPattern --> IdPattern] ; AM |- CM ] ; GM)
      if hilbertProof(Proof) ^
         variableIndex(VM) ^ symbolIndex(SM) ^
         goals([GIndex (N): AM |- CM ] ; GM) ^
         PrState := ProofState
      /\ { ProofState' ^
           goals([GIndex (N): AM |- CM ] ; GM) ^
           hilbertProof(Proof'),
           WfId
         } := wfPatternLemma(IdPattern, ProofState)
      /\ {Proof'', (I)} := propILemma(s getStepNum(Proof'), WfId) [nonexec] .

    vars N M K I I1 I2 WfI GIndex : Nat .
    vars Id Id' WfId WfId' ClaimId : Id .
    vars Proof Proof' Proof'' Pi1 Pi2 PrSt : CommentedProof .
    var V : Var .
    vars P Conclusion IdPattern : Pattern .
    vars PS Assumptions : PatternSet .
    vars S : Symbol .
    vars SM SM' : Map{Symbol,Nat} . vars VM VM' : Map{Var,Nat} .
    vars GM GM' : GoalMap . vars AM AM' AM'' AM1 AM2 : AntecedentMap .
    vars CM CM1 CM2 : ConsequentMap .
    vars ProofState ProofState' PrState : ProofState .
endm

mod AML-PROVER-COMMANDS is including AML-PROOF-STATE-TRANSITIONS .
    inc AML-JUDGEMENTS .
    protecting INT .
    protecting PRINT-AML-GOAL .
    protecting AML-GOAL . protecting AML-USER-THEORY .

    protecting LOOP-MODE .
    protecting PRETTY .
    sorts Tactic MLRule ProverCMD .

    op noop : -> ProverCMD [ctor] .

    op begin`proof`of_assuming_ : Pattern PatternList -> ProverCMD [ctor gather (& E)] .
    op begin`proof`of_ : Pattern -> ProverCMD [prec 42] .
    eq begin proof of P = begin proof of P assuming nil .

    op sg_ : Nat -> ProverCMD [ctor] .
    op switch`goal_ : Nat -> ProverCMD .
    eq switch goal N:Nat = sg N:Nat .

    op pp : -> ProverCMD [ctor] .
    op print`proof : -> ProverCMD .
    eq print proof = pp .

    op pg : -> ProverCMD [ctor] .
    op print`goal : -> ProverCMD .
    eq print goal = pg .

    op pgs : -> ProverCMD [ctor] .
    op print`goals : -> ProverCMD .
    eq print goals = pgs .

    op cp : -> ProverCMD [ctor] .
    op check`proof : -> ProverCMD .
    eq check proof = cp .

    op dp : -> ProverCMD [ctor] .
    op dump`proof : -> ProverCMD .
    eq dump`proof = dp .

    *** Proof Rule Commands ***
    op ax : -> ProverCMD [ctor] .
    op axiom : -> ProverCMD .
    eq axiom = ax .

    op id_ : [Pattern] -> ProverCMD [ctor] .
    op identity_ : [Pattern] -> ProverCMD .
    eq identity P:[Pattern] = id P:[Pattern] .

    *******************************************
    *** Prover Command Application Function ***
    sort CommandResult .
    subsort ProofState QidList < CommandResult .
    op <_#_> : ProofState QidList -> CommandResult [ctor] .
    op noProof : -> CommandResult [ctor] .
    op applyCommand : ProverCMD ProofState -> CommandResult .

    *** Initiate prover loop
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, .ProofState) =
        initializeProofState(Hypotheses, Conclusion) .

    *** Do not overwrite proof with `begin proof`
    eq applyCommand(begin proof of Conclusion assuming Hypotheses, ProofState) =
        ''begin 'proof' 'will 'overwrite 'current 'proof '\n
        'please ''dump 'proof' 'and 'try 'again '\n .

    *** Empty ProofState
    eq applyCommand(CMD:ProverCMD, .ProofState) = noProof [owise] .

    *** Print Goals
    eq applyCommand(pgs, goals(GM) ^ ProofState) = pretty(GM) .

    *** Check Proof
    eq applyCommand(cp, hilbertProof(Proof) ^ ProofState) =
      if check-id(Proof) then
        if check-step(Proof)
          then 'Proof 'is 'valid
          else 'Invalid 'Proof 'Step
          fi
        else 'Invalid 'Proof 'Index
        fi .

    *** Print Proof
    eq applyCommand(pp, hilbertProof(CommentedProof) ^ ProofState) =
        metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) .

    *** Print proof and start over
    eq applyCommand(dp, hilbertProof(CommentedProof) ^ ProofState) =
        < .ProofState # metaPrettyPrint(['AML-CHECKER], upTerm(CommentedProof)) > .

    eq applyCommand(pg, goals([0 (I): G] ; GM) ^ ProofState) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G))  .

    *******************
    *** PROOF RULES ***
    *******************

    *** AXIOM
    ceq applyCommand(ax, ProofState) = ProofState'
      if ProofState' := applyRule(ProofState, 'axiom, 'GIndex:Nat <- upTerm(0), 0, 0) .

    eq applyCommand(ax, ProofState) =
        'No 'match 'for 'AXIOM 'judgement [owise] .

    *** IDENTITY assumption
    eq applyCommand(id P, ProofState) =
        applyRule(ProofState, 'identity,
          *** 'GIndex:Nat <- upTerm(0) ;
          'IdPattern:Pattern <- upTerm(P), 0, 0) .

    eq applyCommand(id P:[Pattern], ProofState) =
        'propI 'failed: '\n '\t
        'input 'pattern 'not 'well-formed [owise] .

*** Helper Functions
    *** Apply a rule contained in the AML-JUDGEMENTS module
    sort JudgementResult .
    subsort ProofState < JudgementResult .
    op failure : -> JudgementResult [ctor] .
    op applyRule : ProofState Qid Substitution Nat Nat -> JudgementResult .
    ceq [applyrule] :
        applyRule(ProofState, Label, Sub, N, M) = downTerm(ProofStateTerm, .ProofState)
      if {ProofStateTerm, Type:Type, Sub', Cont:Context} :=
          metaXapply(['AML-JUDGEMENTS], upTerm(ProofState), Label, Sub, N, unbounded, M)  .
    eq applyRule(ProofState, Label, Sub, N, M) = failure [owise] .


    *** Print Current Goal after successful rule application
    op printSuccess : ProofState -> QidList .
    eq printSuccess(goals([0 (I:Nat): G] ; GM) ^ S) =
        metaPrettyPrint(['PRINT-AML-GOAL], upTerm(G)) .

    vars I N M : Nat .
    vars P Conclusion : Pattern .
    var Hypotheses : PatternList .
    var G : Goal . var GM : GoalMap .
    vars Proof CommentedProof : CommentedProof .
    vars S ProofState ProofState' : ProofState .
    var Label : Qid . var ProofStateTerm : Term . vars Sub Sub' : Substitution .
endm

mod AML-PROVER is
    pr AML-PROVER-COMMANDS .
    including LOOP-MODE .
    including PRETTY .
    pr AML-USER-THEORY .

    subsort ProofState < State .

    vars QIN QOUT QOUT' QOUT'' : QidList .
    vars S S' ProofState : ProofState .
    var T : ResultPair? . var Term : Term . var Type : Type .

    op init : -> System .
    eq init = [nil, .ProofState, nil] .

    *** Loop mode IO rules
    crl [inputCorrectCMDSucceeds] :
        [ QIN, S, QOUT ] => [ nil, S', QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ < S' # QOUT' > := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDSucceeds] :
        [ QIN, S, QOUT ] => [ nil, S', printSuccess(S') ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ S' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDOutput] :
        [ QIN, S, QOUT ] => [ nil, S, QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ QOUT' := applyCommand(downTerm(Term, noop), S) .

    crl [inputCorrectCMDFails] :
        [QIN, S, QOUT ] => [ nil, S, 'Command 'application 'failed ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ not (applyCommand(downTerm(Term, noop), S) :: CommandResult) .

    crl [inputAmbiguous] :
        [ QIN, S, QOUT ] => [ Term, S,
          'Ambiguous 'parse. 'Choosing 'first: '\n
          Term '\n ]
      if QIN =/= nil
      /\ ambiguity({Term, Type}, T) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    crl [proved] :
        [QIN, S ^ goals(mt), QOUT]
      =>
        [QIN, S',
          QOUT'' '\n
          'All 'proof 'goals 'discharged '\n
          QOUT']
      if QOUT' := applyCommand(cp, S ^ goals(mt))
      /\ < S' # QOUT'' > := applyCommand(dp, S ^ goals(mt)) .

    crl [emptyProofState] :
        [ QIN, S, QOUT ] => [nil, S,
          'ERROR: 'There 'is 'no 'proof 'in 'progress '\n
          'try 'begin 'proof 'of 'PATTERN'
          ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ noProof := applyCommand(downTerm(Term, noop), S) .

    crl [inputFail] :
        [ QIN, S, QOUT ] => [ nil, S,
          'ERROR 'on 'input: QIN '\n
          'Parsing 'failed 'at 'column pretty(N:Nat)
          ]
      if QIN =/= nil
      /\ noParse(N:Nat) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    op rewriteProofState : ProofState Bound -> ProofState .
    ceq rewriteProofState(ProofState, B:Bound) = downTerm(Term, .ProofState)
      if {Term, Type} := metaRewrite(['AML-PROVER], upTerm(ProofState), B:Bound) .
endm
