in aml.maude

view ProverCMD from TRIV to AML-PROVER-COMMANDS is sort Elt to ProverCMD . endv

*** Module of functions useful for chaining together prover commands to
*** create executable interactive proofs
mod EXECUTE-PROOF is
    including AML-PROVER .
    including LIST{ProverCMD} *
        ( sort List{ProverCMD} to CmdList
        , sort NeList{ProverCMD} to NeCmdList ) .

    *** Execute a list of prover commands in sequence
    *** starting with the empty ProofState
    op execInteractiveProof : CmdList -> ProofState .
    eq execInteractiveProof(CmdList) = $execInteractiveProof(CmdList, .ProofState) .

    op $execInteractiveProof : CmdList ProofState -> ProofState .
    eq $execInteractiveProof(nil, ProofState) = ProofState .
    eq $execInteractiveProof(Cmd CmdList, ProofState) =
        $execInteractiveProof(CmdList,
          rewriteProofState(
            applyCommand(Cmd, ProofState)
            , unbounded)) .

    *** - Execute a list of proof commands
    *** - check if the proof ends with a proved goal
    *** - send the proof to the proof checker
    *** Returns True if proof is valid, False otherwise
    op execAndCheckProof : CmdList ~> Bool .
    ceq execAndCheckProof(CmdList) = B:Bool
      if ProofState ^ goals(GM) ^ hilbertProof(Proof) :=
          execInteractiveProof(CmdList)
      /\ Pi1 PrStep := Proof
      /\ ClaimId WfId Rl ; := stripComments(PrStep)
      /\ GM' ; [M (I): proved(P, WfId, ClaimId) ] ; GM'' := GM
      /\ B:Bool := check(Proof) .

    vars M N I : Nat .
    var P : Pattern .
    var ProofState : ProofState .
    vars Pi1 Proof : CommentedProof .
    var PrStep : CommentedProofStep .
    vars WfId ClaimId : Id .
    var Rl : AMLRule .
    vars GM GM' GM'' : GoalMap .
    var Cmd : ProverCMD . var CmdList : CmdList .
endm


mod TEST is protecting EXECUTE-PROOF .
    sort TestResult .
    op FAILURE : -> TestResult [ctor format (r d)] .
    op Success : -> TestResult [ctor format (g d)] .

    op _ should be _ : Bool Bool -> TestResult .
    eq Actual should be Expected =
      if Actual == Expected
        then Success
        else FAILURE
        fi .
    eq Actual:[Bool] should be Expected =
      if not Expected
        then Success
        else FAILURE
        fi
        [owise] .

    vars Expected Actual : Bool .
endm

************************
*** BEGIN TEST CASES ***
************************

*** SK calculus proof of tautology `_|_ -> _|_`
reduce execAndCheckProof(
(begin proof of bot --> bot)
(propK bot bot)
(propK bot (bot --> bot))
(propS bot (bot --> bot) bot)
(modus ponens (bot --> (bot --> bot) --> bot) ((bot --> bot --> bot) --> bot --> bot))
(modus ponens (bot --> bot --> bot) (bot --> bot))
(axiom)
) should be true .

*** SK calculus proof of tautology `_|_ -> _|_`
*** Pattern pattern matching for Modus Ponens
reduce execAndCheckProof(
(begin proof of bot --> bot)
(propK bot bot)
(propK bot (bot --> bot))
(propS bot (bot --> bot) bot)
(modus ponens P:Pattern Q:Pattern)
(modus ponens P:Pattern (bot --> bot))
(axiom)
) should be true .

*** Top introduction axiom
reduce execAndCheckProof(
(begin proof of top)
(existence 'x)
(ax)
) should be true .

*** Top introduction axiom false
reduce execAndCheckProof(
(begin proof of top)
(existence 'y)
(ax)
) should be false .

*** identity lemma proof of tautology `_|_ -> _|_`
red execAndCheckProof(
(begin proof of bot --> bot)
(identity bot)
(axiom)
) should be true .

quit
