in aml-prelude.maude
    
mod AML-GOAL is including AML .
    pr PATTERN-SET .
    sort PatternMap .
    op mt : -> PatternMap [ctor] .
    op [_`(_`):_] : Nat Nat Pattern -> PatternMap [ctor] .
    op _;_ : PatternMap PatternMap -> PatternMap [ctor assoc id: mt] .

    sort Goal .
    op _|-_ : PatternMap PatternMap -> Goal [ctor] .
    
    sort GoalMap .
    op mt : -> GoalMap [ctor] .
    op [_`(_`):_] : Nat Nat Goal -> GoalMap [ctor] .
    op _;_ : GoalMap GoalMap -> GoalMap [ctor assoc id: mt] .

    vars N M I I' : Nat .
    vars P P' : Pattern .
    vars G G' : Goal .
    
    *** Pattern and Goal Map invariants
    *** requires: exists a 0 indexed element in the map
    *** ensures: Map is a function from Z_n -> Pattern
    ***              where n is the size of the map
    crl [indexInvariant] : [N (I): P] ; [M (I'): P'] => [N (I): P] ; [s N (I'): P']
      if M == N or M > s N .

    crl [indexInvariant] : [N (I): G] ; [M (I'): G'] => [N (I): G] ; [s N (I'): G']
      if M == N or M > s N .

    *** Construct a PatternMap from a set of Patterns 
    var PS : PatternSet .
    op makePatternMap : PatternSet -> PatternMap .
    eq makePatternMap(PS) = $makePatternMap(PS, 0) .

    op $makePatternMap : PatternSet Nat -> PatternMap .
    eq $makePatternMap(empty, N) = mt .
    eq $makePatternMap((P, PS), N) = [N (0): P] ; $makePatternMap(PS, s N) .    
endm

mod AML-PROOF-STATE is
    pr AML-GOAL .
    inc AML-CHECKER .
    pr PATTERN-SET .
    
    pr MAP{Symbol, Nat} * ( op undefined to undefinedSym, op _|->_ to _|-S>_ ) .
    pr MAP{Var, Nat} * ( op undefined to undefinedVar, op _|->_ to _|-V>_ ) .

    sort ProofStepComments CommentedProof .
    subsort ProofStepComments < ProofStep CommentedProof < Proof .
    op __ : CommentedProof Proof -> CommentedProof [ctor ditto] .
    op __ : Proof CommentedProof -> CommentedProof [ctor ditto] .
    op ___;;_ : Id Claim AMLRule String -> ProofStepComments [ctor] .

    vars Pi1 Pi2 : Proof .
    op stripComments : CommentedProof -> Proof .
    eq stripComments(Pi1 (N:Id C:Claim Rl:AMLRule ;; S:String) Pi2) =
        stripComments(Pi1 (N:Id C:Claim Rl:AMLRule ;) Pi2 ) .
    eq stripComments(Pi1) = Pi1 [owise] .
    
    sort ProofState .
    op .ProofState : -> ProofState [ctor] .
    op _^_ : ProofState ProofState -> ProofState [assoc comm ctor format (d ni s d)] .
    ops goalCounter proofCounter patternCounter : Nat -> ProofState [ctor] .
    op goals : GoalMap -> ProofState [ctor] .
    op symbolIndex : Map{Symbol,Nat} -> ProofState [ctor] .
    op variableIndex : Map{Var,Nat} -> ProofState [ctor] .
    op forwardProof : Proof -> ProofState [ctor] .
    op tacticProof : -> ProofState [ctor] . *** make this

    var Assumptions : PatternSet . vars Assumption Conclusion : Pattern .
    op initializeProofState : PatternSet Pattern -> ProofState .
    eq initializeProofState(Assumptions, Conclusion) =
        tacticProof
        ^ forwardProof((0) (\bot) (WF) ;; "Begin Assumptions")
        ^ proofCounter(1)
        ^ goalCounter(1)
        ^ patternCounter(0)
        ^ symbolIndex(empty)
        ^ variableIndex(empty)
        ^ goals(
          [ 0 (0): makePatternMap(Assumptions)
            |- [0 (0): Conclusion]
            ]
          )
        .

    
endm

mod AML-PROVER-COMMANDS is including AML-PROOF-STATE .
    protecting INT .
    protecting AML-GOAL .
    protecting LOOP-MODE .
    pr PRETTY .
    sorts Tactic MLRule ProverCMD .


    op noop : -> ProverCMD [ctor] .
    op sg_ : Nat -> ProverCMD [ctor] .
    op switch`goal_ : Nat -> ProverCMD .
    eq switch goal N:Nat = sg N:Nat .

    op pp : -> ProverCMD [ctor] .
    op print`proof : -> ProverCMD .
    eq print proof = pp .

    op pg : -> ProverCMD [ctor] .
    op print`goal : -> ProverCMD .
    eq print goal = pg .

    op pgs : -> ProverCMD [ctor] .
    op print`goals : -> ProverCMD .
    eq print goals = pgs .

    op cp : -> ProverCMD [ctor] .
    op check`proof : -> ProverCMD .
    eq check proof = cp .

    ops axiom implyL implyR : -> MLRule [ctor] .
    op assume_ : Pattern -> MLRule [ctor] .

    ops exInstL_ exInstR_ : Qid -> MLRule [ctor] .
    ops exQuant__ : Qid Pattern -> MLRule [ctor] .

    sort CommandResult .
    subsort ProofState QidList < CommandResult .
    op applyCommand : ProverCMD ProofState -> CommandResult .

    vars Proof ProofComments : Proof .
    var ProofState : ProofState .

    *** Check Proof command
    ceq applyCommand(cp, forwardProof(ProofComments) ^ ProofState) =
      if check-id(Proof) then
        if check-step(Proof) then 'Proof 'is 'valid
          else 'Invalid 'Proof 'Step
          fi
        else 'Invalid 'Proof 'Index
        fi
      if Proof := stripComments(ProofComments) .

    *** Print Proof
    eq applyCommand(pp, forwardProof(Proof) ^ ProofState) =
        pretty(Proof) .
endm
    
mod AML-PROVER is
    pr AML-PROVER-COMMANDS .
    including LOOP-MODE .
    including PRETTY .

    subsort ProofState < State .

    vars QIN QOUT QOUT' : QidList .
    var T : ResultPair? .
    var Tac : Tactic .

    vars S S' : ProofState .

    *** initiate prover loop
    op begin`proof`of_assuming_ : Pattern PatternSet -> System .
    eq begin proof of Conclusion:Pattern assuming Assumptions:PatternSet =
        [nil, initializeProofState(Assumptions:PatternSet, Conclusion:Pattern), nil] .
    
    *** Loop mode IO rules
    var Term : Term . var Type : Type . 
    crl [inputCorrectCMDSucceeds] :
        [ QIN, S, QOUT ] => [ nil, S' , 'success '\n ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ S' := applyCommand(downTerm(Term, noop), S) .
    
    crl [inputCorrectCMDOutput] :
        [ QIN, S, QOUT ] => [ nil, S, QOUT' ]
      if QIN =/= nil
      /\ {Term,Type} := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD )
      /\ QOUT' := applyCommand(downTerm(Term, noop), S) .
    
    crl [inputAmbiguous] :
        [ QIN, S, QOUT ] => [ Term, S, 'Ambiguous 'parse. 'Choosing 'first '\n Term '\n ]
      if QIN =/= nil
      /\ ambiguity({Term, Type}, T) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .

    crl [inputFail] :
        [ QIN, S, QOUT ] => [ nil, S,
          'ERROR 'on 'input: QIN '\n
          'Parsing 'failed 'at 'column qid(prettyString(N:Nat))
          ]
      if QIN =/= nil
      /\ noParse(N:Nat) := metaParse(['AML-PROVER-COMMANDS], QIN, 'ProverCMD ) .
endm
